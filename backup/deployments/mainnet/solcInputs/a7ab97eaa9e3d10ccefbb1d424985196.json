{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/accessControl/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./EnumerableSet.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}"
    },
    "contracts/accessControl/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/accessControl/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    },
    "contracts/accessControl/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}"
    },
    "contracts/accessControl/ERC165A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165A {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}"
    },
    "contracts/accessControl/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/common/AccessibleCommon.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165Storage } from \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AccessRoleCommon.sol\";\n\ncontract AccessibleCommon is AccessRoleCommon, ERC165Storage, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender), \"Accessible: Caller is not an admin\");\n        _;\n    }\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyOwner {\n        grantRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    /// @dev remove admin\n    /// @param account  address to remove\n    function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) public virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function transferOwnership(address newAdmin) public virtual onlyOwner {\n        transferAdmin(newAdmin);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function isOwner() public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Storage, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/common/AccessiblePowerTon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AccessRolePowerTon.sol\";\n\ncontract AccessiblePowerTon is AccessRolePowerTon, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender), \"Accessible: Caller is not an admin\");\n        _;\n    }\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyOwner {\n        grantRole(ADMIN_ROLE, account);\n    }\n\n    /// @dev remove admin\n    /// @param account  address to remove\n    function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(ADMIN_ROLE, account);\n    }\n\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(ADMIN_ROLE, newAdmin);\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(ADMIN_ROLE, account);\n    }\n}\n"
    },
    "contracts/common/AccessRoleCommon.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract AccessRoleCommon {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n}\n"
    },
    "contracts/common/AccessRolePowerTon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract AccessRolePowerTon {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER\");\n}\n"
    },
    "contracts/common/AuthControlCoinage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165Storage } from \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AuthRoleCoinage.sol\";\n\ncontract AuthControlCoinage is AuthRoleCoinage, ERC165Storage, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender), \"AuthControl: Caller is not an admin\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, msg.sender), \"AuthControl: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(hasRole(OPERATOR_ROLE, msg.sender), \"AuthControl: Caller is not an operator\");\n        _;\n    }\n\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyOwner {\n        grantRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function addMinter(address account) public virtual onlyOwner {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function addOperator(address account) public virtual onlyOwner {\n        grantRole(OPERATOR_ROLE, account);\n    }\n\n    /// @dev remove admin\n    /// @param account  address to remove\n    function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function removeMinter(address account) public virtual onlyOwner {\n        renounceRole(MINTER_ROLE, account);\n    }\n\n    function removeOperator(address account) public virtual onlyOwner {\n        renounceRole(OPERATOR_ROLE, account);\n    }\n\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) public virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function transferOwnership(address newAdmin) public virtual onlyOwner {\n        transferAdmin(newAdmin);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function renounceMinter() public {\n        renounceRole(MINTER_ROLE, msg.sender);\n    }\n\n    function renounceOperator() public {\n        renounceRole(OPERATOR_ROLE, msg.sender);\n    }\n\n    function revokeMinter(address account) public onlyOwner {\n        revokeRole(MINTER_ROLE, account);\n    }\n\n    function revokeOperator(address account) public onlyOwner {\n        revokeRole(OPERATOR_ROLE, account);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function isOwner() public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function isMinter(address account) public view virtual returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function isOperator(address account) public view virtual returns (bool) {\n        return hasRole(OPERATOR_ROLE, account);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Storage, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/common/AuthControlSeigManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165Storage } from \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AuthRoleSeigManager.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract AuthControlSeigManager is AuthRoleSeigManager, ERC165Storage, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender), \"AuthControl: Caller is not an admin\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, msg.sender), \"AuthControl: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(hasRole(OPERATOR_ROLE, msg.sender), \"AuthControl: Caller is not an operator\");\n        _;\n    }\n\n    modifier onlyChallenger() {\n        require(hasRole(CHALLENGER_ROLE, msg.sender), \"AuthControl: Caller is not a challenger\");\n        _;\n    }\n\n    modifier onlyPauser() {\n        require(hasRole(PAUSE_ROLE, msg.sender), \"AuthControl: Caller is not a pauser\");\n        _;\n    }\n\n    modifier onlyMinterOrAdmin() {\n        console.log('onlyMinterOrAdmin msg.sender ', msg.sender);\n        console.logBool(hasRole(MINTER_ROLE, msg.sender));\n\n        require(isAdmin(msg.sender) || hasRole(MINTER_ROLE, msg.sender), \"not onlyMinterOrAdmin\");\n        _;\n    }\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyOwner {\n        grantRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function addMinter(address account) public virtual onlyOwner {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function addOperator(address account) public virtual onlyOwner {\n        grantRole(OPERATOR_ROLE, account);\n    }\n\n    function addChallenger(address account) public virtual onlyMinterOrAdmin {\n        grantRole(CHALLENGER_ROLE, account);\n    }\n\n    /// @dev remove admin\n    /// @param account  address to remove\n    function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function removeMinter(address account) public virtual onlyOwner {\n        renounceRole(MINTER_ROLE, account);\n    }\n\n    function removeChallenger(address account) public virtual onlyOwner {\n        renounceRole(CHALLENGER_ROLE, account);\n    }\n\n    function removeOperator(address account) public virtual onlyOwner {\n        renounceRole(OPERATOR_ROLE, account);\n    }\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) public virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function transferOwnership(address newAdmin) public virtual onlyOwner {\n        transferAdmin(newAdmin);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function renounceMinter() public {\n        renounceRole(MINTER_ROLE, msg.sender);\n    }\n\n    function renounceOperator() public {\n        renounceRole(OPERATOR_ROLE, msg.sender);\n    }\n\n    function renounceChallenger() public {\n        renounceRole(CHALLENGER_ROLE, msg.sender);\n    }\n\n    function revokeMinter(address account) public onlyOwner {\n        revokeRole(MINTER_ROLE, account);\n    }\n\n    function revokeOperator(address account) public onlyOwner {\n        revokeRole(OPERATOR_ROLE, account);\n    }\n\n    function revokeChallenger(address account) public onlyOwner {\n        revokeRole(CHALLENGER_ROLE, account);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function isOwner() public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function isMinter(address account) public view virtual returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function isOperator(address account) public view virtual returns (bool) {\n        return hasRole(OPERATOR_ROLE, account);\n    }\n\n    function isChallenger(address account) public view virtual returns (bool) {\n        return hasRole(CHALLENGER_ROLE, account);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Storage, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/common/AuthRoleCoinage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract AuthRoleCoinage {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR\");\n}\n"
    },
    "contracts/common/AuthRoleSeigManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract AuthRoleSeigManager {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR\");\n    bytes32 public constant CHALLENGER_ROLE = keccak256(\"CHALLENGER\");\n    bytes32 public constant PAUSE_ROLE = keccak256(\"PAUSE\");\n}\n"
    },
    "contracts/dao/Candidate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IDAOCommittee } from \"./interfaces/IDAOCommittee.sol\";\nimport { IERC20 } from  \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ICandidate } from \"./interfaces/ICandidate.sol\";\nimport { ILayer2 } from \"./interfaces/ILayer2.sol\";\nimport { ILayer2Registry } from \"./interfaces/ILayer2Registry.sol\";\n\nimport \"../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\nimport \"./CandidateStorage.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface ICoinage {\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IOperator {\n  function setWithdrawalDelay(uint256 withdrawalDelay_) external;\n}\n\ninterface IISeigManager {\n  function updateSeigniorage() external returns (bool);\n  function coinages(address layer2) external view returns (address);\n}\n/// @title Managing a candidate\n/// @notice Either a user or layer2 contract can be a candidate\ncontract Candidate is ProxyStorage, AccessibleCommon, CandidateStorage, ILayer2 {\n\n    event TransferCoinage(address from, address to, uint256 amount);\n\n    modifier onlyCandidate() {\n        if (isLayer2Candidate) {\n            ILayer2 layer2 = ILayer2(candidate);\n            require(layer2.operator() == msg.sender, \"Candidate: sender is not the operator of this contract\");\n        } else {\n            require(candidate == msg.sender, \"Candidate: sender is not the candidate of this contract\");\n        }\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(candidate == msg.sender, \"Candidate: sender is not an operator\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return  _supportedInterfaces[interfaceId] || super.supportsInterface(interfaceId) ;\n    }\n\n    // function _registerInterface(bytes4 interfaceId) internal virtual {\n    //     require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n    //     _supportedInterfaces[interfaceId] = true;\n    // }\n\n    function initialize(\n        address _candidate,\n        bool _isLayer2Candidate,\n        string memory _memo,\n        address _committee,\n        address _seigManager\n    ) external  {\n        require(\n            _candidate != address(0)\n            || _committee != address(0)\n            || _seigManager != address(0),\n            \"Candidate: input is zero\"\n        );\n        candidate = _candidate;\n        isLayer2Candidate = _isLayer2Candidate;\n        if (isLayer2Candidate) {\n            require(\n                ILayer2(candidate).isLayer2(),\n                \"Candidate: invalid layer2 contract\"\n            );\n        }\n        committee = _committee;\n        seigManager = _seigManager;\n        memo = _memo;\n\n        _registerInterface(ICandidate(address(this)).isCandidateContract.selector);\n    }\n\n    function setSeigManager(address _seigManager) external onlyOwner {\n        require(_seigManager != address(0), \"Candidate: input is zero\");\n        seigManager = _seigManager;\n    }\n\n    /// @notice Set DAOCommitteeProxy contract address\n    /// @param _committee New DAOCommitteeProxy contract address\n    function setCommittee(address _committee) external onlyOwner {\n        require(_committee != address(0), \"Candidate: input is zero\");\n        committee = _committee;\n    }\n\n    /// @notice Set memo\n    /// @param _memo New memo on this candidate\n    function setMemo(string calldata _memo) external onlyOwner {\n        memo = _memo;\n    }\n\n    /// @notice Set DAOCommitteeProxy contract address\n    /// @notice Call updateSeigniorage on SeigManager\n    /// @return Whether or not the execution succeeded\n    function updateSeigniorage() external returns (bool) {\n        require(seigManager != address(0), \"Candidate: SeigManager is zero\");\n        require(\n            !isLayer2Candidate,\n            \"Candidate: you should update seigniorage from layer2 contract\"\n        );\n\n        require(IISeigManager(seigManager).updateSeigniorage(), \"fail updateSeigniorage\");\n        return true;\n    }\n\n    /// @notice Try to be a member\n    /// @param _memberIndex The index of changing member slot\n    /// @return Whether or not the execution succeeded\n    function changeMember(uint256 _memberIndex)\n        external\n        onlyCandidate\n        returns (bool)\n    {\n        return IDAOCommittee(committee).changeMember(_memberIndex);\n    }\n\n    /// @notice Retire a member\n    /// @return Whether or not the execution succeeded\n    function retireMember() external onlyCandidate returns (bool) {\n        return IDAOCommittee(committee).retireMember();\n    }\n\n    /// @notice Vote on an agenda\n    /// @param _agendaID The agenda ID\n    /// @param _vote voting type\n    /// @param _comment voting comment\n    function castVote(\n        uint256 _agendaID,\n        uint256 _vote,\n        string calldata _comment\n    )\n        external\n        onlyCandidate\n    {\n        IDAOCommittee(committee).castVote(_agendaID, _vote, _comment);\n    }\n\n    function claimActivityReward()\n        external\n        onlyCandidate\n    {\n        address receiver;\n\n        if (isLayer2Candidate) {\n            ILayer2 layer2 = ILayer2(candidate);\n            receiver = layer2.operator();\n        } else {\n            receiver = candidate;\n        }\n        IDAOCommittee(committee).claimActivityReward(receiver);\n    }\n\n    /// @notice Checks whether this contract is a candidate contract\n    /// @return Whether or not this contract is a candidate contract\n    function isCandidateContract() external pure returns (bool) {\n        return true;\n    }\n\n    function isCandidateFwContract() external pure returns (bool) {\n        return true;\n    }\n\n    function operator() external view override returns (address) { return candidate; }\n    function isLayer2() external view override returns (bool) { return true; }\n    function currentFork() external view override returns (uint256) { return 1; }\n    function lastEpoch(uint256 forkNumber) external view override returns (uint256) { return 1; }\n    function changeOperator(address _operator) external override { }\n\n    /// @notice Retrieves the total staked balance on this candidate\n    /// @return totalsupply Total staked amount on this candidate\n    function totalStaked()\n        external\n        view\n        returns (uint256 totalsupply)\n    {\n        IERC20 coinage = _getCoinageToken();\n        return coinage.totalSupply();\n    }\n\n    /// @notice Retrieves the staked balance of the account on this candidate\n    /// @param _account Address being retrieved\n    /// @return amount The staked balance of the account on this candidate\n    function stakedOf(\n        address _account\n    )\n        external\n        view\n        returns (uint256 amount)\n    {\n        IERC20 coinage = _getCoinageToken();\n        return coinage.balanceOf(_account);\n    }\n\n    function _getCoinageToken() internal view returns (IERC20) {\n        address c;\n        if (isLayer2Candidate) {\n            c = candidate;\n        } else {\n            c = address(this);\n        }\n\n        require(c != address(0), \"Candidate: coinage is zero\");\n\n        return IERC20(IISeigManager(seigManager).coinages(c));\n    }\n\n}\n"
    },
    "contracts/dao/CandidateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/Proxy.sol\";\nimport \"./CandidateStorage.sol\";\n\n/**\n * @title CandidateProxy\n * @dev\n */\ncontract CandidateProxy is Proxy, CandidateStorage {\n\n}\n"
    },
    "contracts/dao/CandidateStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract CandidateStorage   {\n    mapping(bytes4 => bool) internal _supportedInterfaces;\n    bool public isLayer2Candidate;\n    address public candidate;\n    string public memo;\n\n    address public committee;\n    address public seigManager;\n\n}\n"
    },
    "contracts/dao/DAOCommitteeExtend.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { IERC20 } from  \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ICandidateFactory } from \"./interfaces/ICandidateFactory.sol\";\n\n// import { IDAOCommittee } from \"./interfaces/IDAOCommittee.sol\";\nimport { ICandidate } from \"./interfaces/ICandidate.sol\";\nimport { ILayer2 } from \"./interfaces/ILayer2.sol\";\nimport { IDAOAgendaManager } from \"./interfaces/IDAOAgendaManager.sol\";\nimport { LibAgenda } from \"./lib/Agenda.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {AccessControl} from \"../accessControl/AccessControl.sol\";\nimport {ERC165A}  from \"../accessControl/ERC165A.sol\";\n\nimport \"./StorageStateCommittee.sol\";\nimport \"./StorageStateCommitteeV2.sol\";\n\n// import \"hardhat/console.sol\";\n\ninterface IICandidateFactory {\n    function setLayerInTimestamp(address _candidateContract) external;\n    function deploy(\n        address _sender,\n        bool _isLayer2Candidate,\n        string memory _name,\n        address _committee,\n        address _seigManager,\n        bool flag\n    )\n        external\n        returns (address operatorAddress, address layer2Address);\n}\n\ninterface ITarget {\n    function setSeigManager(address _seigManager) external;\n}\n\ninterface IPauser {\n    function pause() external ;\n    function unpause() external;\n}\n\ncontract DAOCommitteeExtend is StorageStateCommittee, AccessControl, ERC165A, StorageStateCommitteeV2 {\n    using SafeMath for uint256;\n    using LibAgenda for *;\n\n    enum ApplyResult { NONE, SUCCESS, NOT_ELECTION, ALREADY_COMMITTEE, SLOT_INVALID, ADDMEMBER_FAIL, LOW_BALANCE }\n\n    struct AgendaCreatingData {\n        address[] target;\n        uint128 noticePeriodSeconds;\n        uint128 votingPeriodSeconds;\n        bool atomicExecute;\n        bytes[] functionBytecode;\n    }\n\n    //////////////////////////////\n    // Events\n    //////////////////////////////\n\n    event QuorumChanged(\n        uint256 newQuorum\n    );\n\n    event AgendaCreated(\n        address indexed from,\n        uint256 indexed id,\n        address[] targets,\n        uint128 noticePeriodSeconds,\n        uint128 votingPeriodSeconds,\n        bool atomicExecute\n    );\n\n    event AgendaVoteCasted(\n        address indexed from,\n        uint256 indexed id,\n        uint256 voting,\n        string comment\n    );\n\n    event AgendaExecuted(\n        uint256 indexed id,\n        address[] target\n    );\n\n    event CandidateContractCreated(\n        address indexed candidate,\n        address indexed candidateContract,\n        string memo\n    );\n\n    event Layer2Registered(\n        address indexed candidate,\n        address indexed candidateContract,\n        string memo\n    );\n\n    event ChangedMember(\n        uint256 indexed slotIndex,\n        address prevMember,\n        address indexed newMember\n    );\n\n    event ChangedSlotMaximum(\n        uint256 indexed prevSlotMax,\n        uint256 indexed slotMax\n    );\n\n    event ClaimedActivityReward(\n        address indexed candidate,\n        address receiver,\n        uint256 amount\n    );\n\n    event ChangedMemo(\n        address candidate,\n        string newMemo\n    );\n\n    event ActivityRewardChanged(\n        uint256 newReward\n    );\n\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DAOCommittee: msg.sender is not an admin\");\n        _;\n    }\n\n    modifier validMemberIndex(uint256 _index) {\n        require(_index < maxMember, \"DAOCommittee: invalid member index\");\n        _;\n    }\n\n    modifier nonZero(address _addr) {\n        require(_addr != address(0), \"DAOCommittee: zero address\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override (ERC165A) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // setters\n\n    /// @notice Set SeigManager contract address\n    /// @param _seigManager New SeigManager contract address\n    function setSeigManager(address _seigManager) external onlyOwner nonZero(_seigManager) {\n        seigManager = ISeigManager(_seigManager);\n    }\n\n    function setTargetSeigManager(address target, address _seigManager) external onlyOwner {\n        ITarget(target).setSeigManager(_seigManager);\n    }\n\n    function setSeigPause() external onlyOwner {\n       IPauser(address(seigManager)).pause();\n    }\n\n    function setSeigUnpause() external onlyOwner {\n       IPauser(address(seigManager)).unpause();\n    }\n\n    /// @notice Set SeigManager contract address on candidate contracts\n    /// @param _candidateContracts Candidate contracts to be set\n    /// @param _seigManager New SeigManager contract address\n    // function setCandidatesSeigManager(\n    //     address[] calldata _candidateContracts,\n    //     address _seigManager\n    // )\n    //     external\n    //     onlyOwner\n    //     nonZero(_seigManager)\n    // {\n    //     for (uint256 i = 0; i < _candidateContracts.length; i++) {\n    //         ICandidate(_candidateContracts[i]).setSeigManager(_seigManager);\n    //     }\n    // }\n\n    /// @notice Set DAOCommitteeProxy contract address on candidate contracts\n    /// @param _candidateContracts Candidate contracts to be set\n    /// @param _committee New DAOCommitteeProxy contract address\n    // function setCandidatesCommittee(\n    //     address[] calldata _candidateContracts,\n    //     address _committee\n    // )\n    //     external\n    //     onlyOwner\n    //     nonZero(_committee)\n    // {\n    //     for (uint256 i = 0; i < _candidateContracts.length; i++) {\n    //         ICandidate(_candidateContracts[i]).setCommittee(_committee);\n    //     }\n    // }\n\n    /// @notice Set DAOVault contract address\n    /// @param _daoVault New DAOVault contract address\n    function setDaoVault(address _daoVault) external onlyOwner nonZero(_daoVault) {\n        daoVault = IDAOVault(_daoVault);\n    }\n\n    /// @notice Set Layer2Registry contract address\n    /// @param _layer2Registry New Layer2Registry contract address\n    function setLayer2Registry(address _layer2Registry) external onlyOwner nonZero(_layer2Registry) {\n        layer2Registry = ILayer2Registry(_layer2Registry);\n    }\n\n    /// @notice Set DAOAgendaManager contract address\n    /// @param _agendaManager New DAOAgendaManager contract address\n    // function setAgendaManager(address _agendaManager) external override onlyOwner nonZero(_agendaManager) {\n    //     agendaManager = IDAOAgendaManager(_agendaManager);\n    // }\n\n    /// @notice Set CandidateFactory contract address\n    /// @param _candidateFactory New CandidateFactory contract address\n    function setCandidateFactory(address _candidateFactory) external onlyOwner nonZero(_candidateFactory) {\n        candidateFactory = ICandidateFactory(_candidateFactory);\n    }\n\n    /// @notice Set TON contract address\n    /// @param _ton New TON contract address\n    // function setTon(address _ton) external onlyOwner nonZero(_ton) {\n    //     ton = _ton;\n    // }\n\n    /// @notice Set activity reward amount\n    /// @param _value New activity reward per second\n    // function setActivityRewardPerSecond(uint256 _value) external onlyOwner {\n    //     activityRewardPerSecond = _value;\n    //     emit ActivityRewardChanged(_value);\n    // }\n\n    /// @notice Increases the number of member slot\n    /// @param _newMaxMember New number of member slot\n    /// @param _quorum New quorum\n    function increaseMaxMember(\n        uint256 _newMaxMember,\n        uint256 _quorum\n    )\n        external\n        onlyOwner\n    {\n        require(maxMember < _newMaxMember, \"DAOCommittee: You have to call decreaseMaxMember to decrease\");\n        uint256 prevMaxMember = maxMember;\n        maxMember = _newMaxMember;\n        fillMemberSlot();\n        setQuorum(_quorum);\n        emit ChangedSlotMaximum(prevMaxMember, _newMaxMember);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Managing members\n    function createCandidate(string calldata _memo)\n        external\n    {\n        address _operator = msg.sender;\n        require(!isExistCandidate(_operator), \"DAOCommittee: candidate already registerd\");\n\n        // Candidate\n        address candidateContract = candidateFactory.deploy(\n            _operator,\n            false,\n            _memo,\n            address(this),\n            address(seigManager)\n        );\n\n        require(\n            candidateContract != address(0),\n            \"DAOCommittee: deployed candidateContract is zero\"\n        );\n        require(\n            _candidateInfos[_operator].candidateContract == address(0),\n            \"DAOCommittee: The candidate already has contract\"\n        );\n        require(\n            layer2Registry.registerAndDeployCoinage(candidateContract, address(seigManager)),\n            \"DAOCommittee: failed to registerAndDeployCoinage\"\n        );\n\n        _candidateInfos[_operator] = CandidateInfo({\n            candidateContract: candidateContract,\n            memberJoinedTime: 0,\n            indexMembers: 0,\n            rewardPeriod: 0,\n            claimedTimestamp: 0\n        });\n\n        candidates.push(_operator);\n\n        emit CandidateContractCreated(_operator, candidateContract, _memo);\n\n    }\n\n    // 한 오퍼레이터가 여러개의 candidate를 가질 수 없다.\n    // 따라서, 오퍼레이터 컨트랙을 만들어내야 한다. 오퍼레이터 컨트랙의 오너를 지정할 수 있게 한다.\n    function createCandidate(string calldata _memo, address _operatorAddress)\n        public\n        validSeigManager\n        validLayer2Registry\n        validCommitteeL2Factory\n        onlyOwner\n    {\n        // Candidate\n        address candidateContract = candidateFactory.deploy(\n            _operatorAddress,\n            false,\n            _memo,\n            address(this),\n            address(seigManager)\n        );\n\n        require(\n            candidateContract != address(0),\n            \"DAOCommittee: deployed candidateContract is zero\"\n        );\n\n        // require(\n        //     _candidateInfos[_operatorAddress].candidateContract == address(0),\n        //     \"DAOCommittee: The candidate already has contract\"\n        // );\n\n        if(_candidateInfos[_operatorAddress].candidateContract != address(0) ) {\n\n            require(_oldCandidateInfos[_operatorAddress].candidateContract == address(0), \"already migrated\");\n\n            _oldCandidateInfos[_operatorAddress] = CandidateInfo2({\n                candidateContract: _candidateInfos[_operatorAddress].candidateContract,\n                memberJoinedTime: _candidateInfos[_operatorAddress].memberJoinedTime,\n                indexMembers: _candidateInfos[_operatorAddress].indexMembers,\n                rewardPeriod: _candidateInfos[_operatorAddress].rewardPeriod,\n                claimedTimestamp: _candidateInfos[_operatorAddress].claimedTimestamp\n            });\n\n            _candidateInfos[_operatorAddress].candidateContract = candidateContract;\n\n        } else {\n\n            _candidateInfos[_operatorAddress] = CandidateInfo({\n                candidateContract: candidateContract,\n                memberJoinedTime: 0,\n                indexMembers: 0,\n                rewardPeriod: 0,\n                claimedTimestamp: 0\n            });\n\n            candidates.push(_operatorAddress);\n        }\n\n        require(\n            layer2Registry.registerAndDeployCoinage(candidateContract, address(seigManager)),\n            \"DAOCommittee: failed to registerAndDeployCoinage\"\n        );\n\n        emit CandidateContractCreated(_operatorAddress, candidateContract, _memo);\n    }\n\n    /// @notice Registers the exist layer2 on DAO\n    /// @param _layer2 Layer2 contract address to be registered\n    /// @param _memo A memo for the candidate\n    function registerLayer2Candidate(address _layer2, string memory _memo)\n        external\n        validSeigManager\n        validLayer2Registry\n        validCommitteeL2Factory\n    {\n        _registerLayer2Candidate(msg.sender, _layer2, _memo);\n    }\n\n    /// @notice Registers the exist layer2 on DAO by owner\n    /// @param _operator Operator address of the layer2 contract\n    /// @param _layer2 Layer2 contract address to be registered\n    /// @param _memo A memo for the candidate\n    function registerLayer2CandidateByOwner(address _operator, address _layer2, string memory _memo)\n        external\n        onlyOwner\n        validSeigManager\n        validLayer2Registry\n        validCommitteeL2Factory\n    {\n        _registerLayer2Candidate(_operator, _layer2, _memo);\n    }\n\n    /// @notice Replaces an existing member\n    /// @param _memberIndex The member slot index to be replaced\n    /// @return Whether or not the execution succeeded\n    function changeMember(\n        uint256 _memberIndex\n    )\n        external\n        validMemberIndex(_memberIndex)\n        returns (bool)\n    {\n        address newMember = ICandidate(msg.sender).candidate();\n        CandidateInfo storage candidateInfo = _candidateInfos[newMember];\n        require(\n            ICandidate(msg.sender).isCandidateContract(),\n            \"DAOCommittee: sender is not a candidate contract\"\n        );\n        require(\n            candidateInfo.candidateContract == msg.sender,\n            \"DAOCommittee: invalid candidate contract\"\n        );\n        require(\n            candidateInfo.memberJoinedTime == 0,\n            \"DAOCommittee: already member\"\n        );\n\n        address prevMember = members[_memberIndex];\n        address prevMemberContract = candidateContract(prevMember);\n\n        candidateInfo.memberJoinedTime = uint128(block.timestamp);\n        candidateInfo.indexMembers = _memberIndex;\n\n        members[_memberIndex] = newMember;\n\n        if (prevMember == address(0)) {\n            emit ChangedMember(_memberIndex, prevMember, newMember);\n            return true;\n        }\n\n        require(\n            ICandidate(msg.sender).totalStaked() > ICandidate(prevMemberContract).totalStaked(),\n            \"not enough amount\"\n        );\n\n        CandidateInfo storage prevCandidateInfo = _candidateInfos[prevMember];\n        prevCandidateInfo.indexMembers = 0;\n        prevCandidateInfo.rewardPeriod = uint128(uint256(prevCandidateInfo.rewardPeriod).add(block.timestamp.sub(prevCandidateInfo.memberJoinedTime)));\n        prevCandidateInfo.memberJoinedTime = 0;\n\n        emit ChangedMember(_memberIndex, prevMember, newMember);\n\n        return true;\n    }\n\n    /// @notice Retires member\n    /// @return Whether or not the execution succeeded\n    function retireMember() onlyMemberContract external returns (bool) {\n        address candidate = ICandidate(msg.sender).candidate();\n        CandidateInfo storage candidateInfo = _candidateInfos[candidate];\n        require(\n            candidateInfo.candidateContract == msg.sender,\n            \"DAOCommittee: invalid candidate contract\"\n        );\n        members[candidateInfo.indexMembers] = address(0);\n        candidateInfo.rewardPeriod = uint128(uint256(candidateInfo.rewardPeriod).add(block.timestamp.sub(candidateInfo.memberJoinedTime)));\n        candidateInfo.memberJoinedTime = 0;\n\n        uint256 prevIndex = candidateInfo.indexMembers;\n        candidateInfo.indexMembers = 0;\n        emit ChangedMember(prevIndex, candidate, address(0));\n\n        return true;\n    }\n\n    /// @notice Set memo\n    /// @param _candidate candidate address\n    /// @param _memo New memo on this candidate\n    function setMemoOnCandidate(\n        address _candidate,\n        string calldata _memo\n    )\n        external\n    {\n        address candidateContract = candidateContract(_candidate);\n        setMemoOnCandidateContract(candidateContract, _memo);\n    }\n\n    /// @notice Set memo\n    /// @param _candidateContract candidate contract address\n    /// @param _memo New memo on this candidate\n    function setMemoOnCandidateContract(\n        address _candidateContract,\n        string calldata _memo\n    )\n        public\n    {\n        address candidate = ICandidate(_candidateContract).candidate();\n        address contractOwner = candidate;\n        if (ICandidate(_candidateContract).isLayer2Candidate()) {\n            contractOwner = ILayer2(candidate).operator();\n        }\n        require(\n            msg.sender == contractOwner,\n            \"DAOCommittee: sender is not the candidate of this contract\"\n        );\n\n        ICandidate(_candidateContract).setMemo(_memo);\n        emit ChangedMemo(candidate, _memo);\n    }\n\n    /// @notice Decreases the number of member slot\n    /// @param _reducingMemberIndex Reducing member slot index\n    /// @param _quorum New quorum\n    function decreaseMaxMember(\n        uint256 _reducingMemberIndex,\n        uint256 _quorum\n    )\n        external\n        onlyOwner\n        validMemberIndex(_reducingMemberIndex)\n    {\n        address reducingMember = members[_reducingMemberIndex];\n        CandidateInfo storage reducingCandidate = _candidateInfos[reducingMember];\n\n        if (_reducingMemberIndex != members.length - 1) {\n            address tailMember = members[members.length - 1];\n            CandidateInfo storage tailCandidate = _candidateInfos[tailMember];\n\n            tailCandidate.indexMembers = _reducingMemberIndex;\n            members[_reducingMemberIndex] = tailMember;\n        }\n        reducingCandidate.indexMembers = 0;\n        reducingCandidate.rewardPeriod = uint128(uint256(reducingCandidate.rewardPeriod).add(block.timestamp.sub(reducingCandidate.memberJoinedTime)));\n        reducingCandidate.memberJoinedTime = 0;\n\n        members.pop();\n        maxMember = maxMember.sub(1);\n        setQuorum(_quorum);\n\n        emit ChangedMember(_reducingMemberIndex, reducingMember, address(0));\n        emit ChangedSlotMaximum(maxMember.add(1), maxMember);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Managing agenda\n\n    function onApprove(\n        address owner,\n        address spender,\n        uint256 tonAmount,\n        bytes calldata data\n    ) external returns (bool) {\n        AgendaCreatingData memory agendaData = _decodeAgendaData(data);\n\n        _createAgenda(\n            owner,\n            agendaData.target,\n            agendaData.noticePeriodSeconds,\n            agendaData.votingPeriodSeconds,\n            agendaData.atomicExecute,\n            agendaData.functionBytecode\n        );\n\n        return true;\n    }\n\n    /// @notice Set new quorum\n    /// @param _quorum New quorum\n    function setQuorum(\n        uint256 _quorum\n    )\n        public\n        onlyOwner\n        validAgendaManager\n    {\n        require(_quorum > maxMember.div(2), \"DAOCommittee: invalid quorum\");\n        require(_quorum <= maxMember, \"DAOCommittee: quorum exceed max member\");\n        quorum = _quorum;\n        emit QuorumChanged(quorum);\n    }\n\n    /// @notice Set fee amount of creating an agenda\n    /// @param _fees Fee amount on TON\n    function setCreateAgendaFees(\n        uint256 _fees\n    )\n        external\n        onlyOwner\n        validAgendaManager\n    {\n        agendaManager.setCreateAgendaFees(_fees);\n    }\n\n    /// @notice Set the minimum notice period\n    /// @param _minimumNoticePeriod New minimum notice period in second\n    function setMinimumNoticePeriodSeconds(\n        uint256 _minimumNoticePeriod\n    )\n        external\n        onlyOwner\n        validAgendaManager\n    {\n        agendaManager.setMinimumNoticePeriodSeconds(_minimumNoticePeriod);\n    }\n\n    /// @notice Set the minimum voting period\n    /// @param _minimumVotingPeriod New minimum voting period in second\n    function setMinimumVotingPeriodSeconds(\n        uint256 _minimumVotingPeriod\n    )\n        external\n        onlyOwner\n        validAgendaManager\n    {\n        agendaManager.setMinimumVotingPeriodSeconds(_minimumVotingPeriod);\n    }\n\n    /// @notice Set the executing period\n    /// @param _executingPeriodSeconds New executing period in second\n    function setExecutingPeriodSeconds(\n        uint256 _executingPeriodSeconds\n    )\n        external\n        onlyOwner\n        validAgendaManager\n    {\n        agendaManager.setExecutingPeriodSeconds(_executingPeriodSeconds);\n    }\n\n    /// @notice Vote on an agenda\n    /// @param _agendaID The agenda ID\n    /// @param _vote voting type\n    /// @param _comment voting comment\n    function castVote(\n        uint256 _agendaID,\n        uint256 _vote,\n        string calldata _comment\n    )\n        external\n        validAgendaManager\n    {\n        address candidate = ICandidate(msg.sender).candidate();\n        CandidateInfo storage candidateInfo = _candidateInfos[candidate];\n        require(\n            candidateInfo.candidateContract == msg.sender,\n            \"DAOCommittee: invalid candidate contract\"\n        );\n\n        agendaManager.castVote(\n            _agendaID,\n            candidate,\n            _vote\n        );\n\n        (uint256 yes, uint256 no, uint256 abstain) = agendaManager.getVotingCount(_agendaID);\n\n        if (quorum <= yes) {\n            // yes\n            agendaManager.setResult(_agendaID, LibAgenda.AgendaResult.ACCEPT);\n            agendaManager.setStatus(_agendaID, LibAgenda.AgendaStatus.WAITING_EXEC);\n        } else if (quorum <= no) {\n            // no\n            agendaManager.setResult(_agendaID, LibAgenda.AgendaResult.REJECT);\n            agendaManager.setStatus(_agendaID, LibAgenda.AgendaStatus.ENDED);\n        } else if (quorum <= abstain.add(no)) {\n            // dismiss\n            agendaManager.setResult(_agendaID, LibAgenda.AgendaResult.DISMISS);\n            agendaManager.setStatus(_agendaID, LibAgenda.AgendaStatus.ENDED);\n        }\n\n        emit AgendaVoteCasted(msg.sender, _agendaID, _vote, _comment);\n    }\n\n    /// @notice Set the agenda status as ended(denied or dismissed)\n    /// @param _agendaID Agenda ID\n    function endAgendaVoting(uint256 _agendaID) external {\n        agendaManager.endAgendaVoting(_agendaID);\n    }\n\n    /// @notice Execute the accepted agenda\n    /// @param _agendaID Agenda ID\n    function executeAgenda(uint256 _agendaID) external validAgendaManager {\n        require(\n            agendaManager.canExecuteAgenda(_agendaID),\n            \"DAOCommittee: can not execute the agenda\"\n        );\n\n         (address[] memory target,\n             bytes[] memory functionBytecode,\n             bool atomicExecute,\n             uint256 executeStartFrom\n         ) = agendaManager.getExecutionInfo(_agendaID);\n\n        if (atomicExecute) {\n            agendaManager.setExecutedAgenda(_agendaID);\n            for (uint256 i = 0; i < target.length; i++) {\n                (bool success, ) = address(target[i]).call(functionBytecode[i]);\n                require(success, \"DAOCommittee: Failed to execute the agenda\");\n            }\n        } else {\n            uint256 succeeded = 0;\n            for (uint256 i = executeStartFrom; i < target.length; i++) {\n                bool success = _call(target[i], functionBytecode[i].length, functionBytecode[i]);\n                if (success) {\n                    succeeded = succeeded.add(1);\n                } else {\n                    break;\n                }\n            }\n\n            agendaManager.setExecutedCount(_agendaID, succeeded);\n            if (executeStartFrom.add(succeeded) == target.length) {\n                agendaManager.setExecutedAgenda(_agendaID);\n            }\n        }\n\n        emit AgendaExecuted(_agendaID, target);\n    }\n\n    /// @notice Set status and result of specific agenda\n    /// @param _agendaID Agenda ID\n    /// @param _status New status\n    /// @param _result New result\n    function setAgendaStatus(uint256 _agendaID, uint256 _status, uint256 _result) external onlyOwner {\n        agendaManager.setResult(_agendaID, LibAgenda.AgendaResult(_result));\n        agendaManager.setStatus(_agendaID, LibAgenda.AgendaStatus(_status));\n    }\n\n    /// @notice Call updateSeigniorage on SeigManager\n    /// @param _candidate Candidate address to be updated\n    /// @return Whether or not the execution succeeded\n    function updateSeigniorage(address _candidate) public returns (bool) {\n        address candidateContract = _candidateInfos[_candidate].candidateContract;\n        return ICandidate(candidateContract).updateSeigniorage();\n    }\n\n    /// @notice Call updateSeigniorage on SeigManager\n    /// @param _candidates Candidate addresses to be updated\n    /// @return Whether or not the execution succeeded\n    function updateSeigniorages(address[] calldata _candidates) external returns (bool) {\n        for (uint256 i = 0; i < _candidates.length; i++) {\n            require(\n                updateSeigniorage(_candidates[i]),\n                \"DAOCommittee: failed to update seigniorage\"\n            );\n        }\n\n        return true;\n    }\n\n    /// @notice Claims the activity reward for member\n    function claimActivityReward(address _receiver) external {\n        address candidate = ICandidate(msg.sender).candidate();\n        CandidateInfo storage candidateInfo = _candidateInfos[candidate];\n        require(\n            candidateInfo.candidateContract == msg.sender,\n            \"DAOCommittee: invalid candidate contract\"\n        );\n\n        uint256 amount = getClaimableActivityReward(candidate);\n        require(amount > 0, \"DAOCommittee: you don't have claimable ton\");\n\n        daoVault.claimTON(_receiver, amount);\n        candidateInfo.claimedTimestamp = uint128(block.timestamp);\n        candidateInfo.rewardPeriod = 0;\n\n        emit ClaimedActivityReward(candidate, _receiver, amount);\n    }\n\n    function _registerLayer2Candidate(address _operator, address _layer2, string memory _memo)\n        internal\n        validSeigManager\n        validLayer2Registry\n        validCommitteeL2Factory\n    {\n        require(!isExistCandidate(_layer2), \"DAOCommittee: candidate already registerd\");\n\n        require(\n            _layer2 != address(0),\n            \"DAOCommittee: deployed candidateContract is zero\"\n        );\n        require(\n            _candidateInfos[_layer2].candidateContract == address(0),\n            \"DAOCommittee: The candidate already has contract\"\n        );\n        ILayer2 layer2 = ILayer2(_layer2);\n        require(\n            layer2.isLayer2(),\n            \"DAOCommittee: invalid layer2 contract\"\n        );\n        require(\n            layer2.operator() == _operator,\n            \"DAOCommittee: invalid operator\"\n        );\n\n        address candidateContract = candidateFactory.deploy(\n            _layer2,\n            true,\n            _memo,\n            address(this),\n            address(seigManager)\n        );\n\n        require(\n            candidateContract != address(0),\n            \"DAOCommittee: deployed candidateContract is zero\"\n        );\n\n        _candidateInfos[_layer2] = CandidateInfo({\n            candidateContract: candidateContract,\n            memberJoinedTime: 0,\n            indexMembers: 0,\n            rewardPeriod: 0,\n            claimedTimestamp: 0\n        });\n\n        candidates.push(_layer2);\n\n        emit Layer2Registered(_layer2, candidateContract, _memo);\n    }\n\n    function fillMemberSlot() internal {\n        for (uint256 i = members.length; i < maxMember; i++) {\n            members.push(address(0));\n        }\n    }\n\n    function _decodeAgendaData(bytes calldata input)\n        internal\n        view\n        returns (AgendaCreatingData memory data)\n    {\n        (data.target, data.noticePeriodSeconds, data.votingPeriodSeconds, data.atomicExecute, data.functionBytecode) =\n            abi.decode(input, (address[], uint128, uint128, bool, bytes[]));\n    }\n\n    function payCreatingAgendaFee(address _creator) internal {\n        uint256 fee = agendaManager.createAgendaFees();\n\n        require(IERC20(ton).transferFrom(_creator, address(this), fee), \"DAOCommittee: failed to transfer ton from creator\");\n        require(IERC20(ton).transfer(address(1), fee), \"DAOCommittee: failed to burn\");\n    }\n\n    function _createAgenda(\n        address _creator,\n        address[] memory _targets,\n        uint128 _noticePeriodSeconds,\n        uint128 _votingPeriodSeconds,\n        bool _atomicExecute,\n        bytes[] memory _functionBytecodes\n    )\n        internal\n        validAgendaManager\n        returns (uint256)\n    {\n        // pay to create agenda, burn ton.\n        payCreatingAgendaFee(_creator);\n\n        uint256 agendaID = agendaManager.newAgenda(\n            _targets,\n            _noticePeriodSeconds,\n            _votingPeriodSeconds,\n            _atomicExecute,\n            _functionBytecodes\n        );\n\n        emit AgendaCreated(\n            _creator,\n            agendaID,\n            _targets,\n            _noticePeriodSeconds,\n            _votingPeriodSeconds,\n            _atomicExecute\n        );\n\n        return agendaID;\n    }\n\n    function _call(address target, uint256 paramLength, bytes memory param) internal returns (bool) {\n        bool result;\n        assembly {\n            let data := add(param, 32)\n            result := call(sub(gas(), 40000), target, 0, data, paramLength, 0, 0)\n        }\n\n        return result;\n    }\n\n    function isCandidate(address _candidate) external view returns (bool) {\n        CandidateInfo storage info = _candidateInfos[_candidate];\n\n        if (info.candidateContract == address(0)) {\n            return false;\n        }\n\n        bool supportIsCandidateContract = ERC165Checker.supportsInterface(\n            info.candidateContract,\n            ICandidate(info.candidateContract).isCandidateContract.selector\n        );\n\n        if (supportIsCandidateContract == false) {\n            return false;\n        }\n\n        return ICandidate(info.candidateContract).isCandidateContract();\n    }\n\n    function totalSupplyOnCandidate(\n        address _candidate\n    )\n        external\n        view\n        returns (uint256 totalsupply)\n    {\n        address candidateContract = candidateContract(_candidate);\n        return totalSupplyOnCandidateContract(candidateContract);\n    }\n\n    function balanceOfOnCandidate(\n        address _candidate,\n        address _account\n    )\n        external\n        view\n        returns (uint256 amount)\n    {\n        address candidateContract = candidateContract(_candidate);\n        return balanceOfOnCandidateContract(candidateContract, _account);\n    }\n\n    function totalSupplyOnCandidateContract(\n        address _candidateContract\n    )\n        public\n        view\n        returns (uint256 totalsupply)\n    {\n        require(_candidateContract != address(0), \"This account is not a candidate\");\n\n        return ICandidate(_candidateContract).totalStaked();\n    }\n\n    function balanceOfOnCandidateContract(\n        address _candidateContract,\n        address _account\n    )\n        public\n        view\n        returns (uint256 amount)\n    {\n        require(_candidateContract != address(0), \"This account is not a candidate\");\n\n        return ICandidate(_candidateContract).stakedOf(_account);\n    }\n\n    function candidatesLength() external view returns (uint256) {\n        return candidates.length;\n    }\n\n    function isExistCandidate(address _candidate) public view returns (bool isExist) {\n        return _candidateInfos[_candidate].candidateContract != address(0);\n    }\n\n    function getClaimableActivityReward(address _candidate) public view returns (uint256) {\n        CandidateInfo storage info = _candidateInfos[_candidate];\n        uint256 period = info.rewardPeriod;\n\n        if (info.memberJoinedTime > 0) {\n            if (info.memberJoinedTime > info.claimedTimestamp) {\n                period = period.add(block.timestamp.sub(info.memberJoinedTime));\n            } else {\n                period = period.add(block.timestamp.sub(info.claimedTimestamp));\n            }\n        }\n\n        return period.mul(activityRewardPerSecond);\n        // return 0;\n    }\n}\n"
    },
    "contracts/dao/factory/CandidateFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { Operator } from \"../Operator.sol\";\nimport { CandidateProxy } from \"../CandidateProxy.sol\";\n\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\nimport \"./CandidateFactoryStorage.sol\";\n// import \"hardhat/console.sol\";\n\ninterface ICandidate {\n    function initialize(\n        address _candidate,\n        bool _isLayer2Candidate,\n        string memory _memo,\n        address _committee,\n        address _seigManager\n    ) external;\n}\n\ncontract CandidateFactory is ProxyStorage, AccessibleCommon, CandidateFactoryStorage {\n\n    event DeployedCandidate(\n        address sender,\n        address layer2,\n        address operator,\n        bool isLayer2Candidate,\n        string name,\n        address committee,\n        address seigManager\n    );\n\n    function setAddress(\n        address _depositManager,\n        address _daoCommittee,\n        address _candidateImp,\n        address _ton,\n        address _wton\n    ) external onlyOwner {\n        require(\n            _ton != address(0) && _wton != address(0) &&\n            _depositManager != address(0) && _daoCommittee != address(0) && _candidateImp != address(0)  , \"zero\");\n\n        require(\n            ton != _ton || wton != _wton ||\n            depositManager != _depositManager || daoCommittee != _daoCommittee || candidateImp != _candidateImp  , \"same\");\n\n        depositManager = _depositManager;\n        daoCommittee = _daoCommittee;\n        candidateImp = _candidateImp;\n        ton = _ton;\n        wton = _wton;\n    }\n\n    function deploy(\n        address _sender,\n        bool _isLayer2Candidate,\n        string memory _name,\n        address _committee,\n        address _seigManager,\n        bool flag\n    )\n        public\n        returns (address operatorAddress, address layer2Address)\n    {\n        require(msg.sender == daoCommittee, \"sender is not daoCommittee\");\n        require(daoCommittee == _committee, \"different daoCommittee\");\n        Operator operator = new Operator(depositManager, daoCommittee, ton, wton);\n\n        operatorAddress = address(operator);\n        require(operatorAddress!= address(0), 'zero operator');\n\n        CandidateProxy c = new CandidateProxy();\n        require(address(c) != address(0), \"zero CandidateFwProxy\");\n        layer2Address = address(c);\n        c.upgradeTo(candidateImp);\n\n        ICandidate(address(c)).initialize(\n            operatorAddress,\n            _isLayer2Candidate,\n            _name,\n            _committee,\n            _seigManager\n        );\n\n        c.transferAdmin(_committee);\n\n        operator.setLayer(layer2Address);\n        operator.transferAdmin(_sender);\n\n        emit DeployedCandidate(\n            _sender,\n            address(c),\n            address(operator),\n            _isLayer2Candidate,\n            _name,\n            _committee,\n            _seigManager\n        );\n    }\n\n    function deploy(\n        address _sender,\n        bool _isLayer2Candidate,\n        string memory _name,\n        address _committee,\n        address _seigManager\n    )\n        public\n        returns (address)\n    {\n        require(msg.sender == daoCommittee, \"sender is not daoCommittee\");\n        require(daoCommittee == _committee, \"different daoCommittee\");\n        CandidateProxy c = new CandidateProxy();\n        require(address(c) != address(0), \"zero CandidateFwProxy\");\n\n        c.upgradeTo(candidateImp);\n\n        ICandidate(address(c)).initialize(\n            _sender,\n            _isLayer2Candidate,\n            _name,\n            _committee,\n            _seigManager\n        );\n\n        c.transferAdmin(_committee);\n\n        emit DeployedCandidate(\n            _sender,\n            address(c),\n            _sender,\n            _isLayer2Candidate,\n            _name,\n            _committee,\n            _seigManager\n        );\n        return address(c);\n    }\n\n}\n"
    },
    "contracts/dao/factory/CandidateFactoryProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/Proxy.sol\";\nimport \"./CandidateFactoryStorage.sol\";\n\n/**\n * @title CandidateFactoryProxy\n * @dev\n */\ncontract CandidateFactoryProxy is Proxy, CandidateFactoryStorage {\n\n}\n"
    },
    "contracts/dao/factory/CandidateFactoryStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract CandidateFactoryStorage  {\n\n  address public depositManager;\n  address public daoCommittee;\n  address public candidateImp;\n  address public ton;\n  address public wton;\n\n}\n"
    },
    "contracts/dao/interfaces/CoinageFactoryI.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface CoinageFactoryI {\n  function deploy() external returns (address);\n}\n"
    },
    "contracts/dao/interfaces/ICandidate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ICandidate {\n    function setSeigManager(address _seigMan) external;\n    function setCommittee(address _committee) external;\n    function updateSeigniorage() external returns (bool);\n    function changeMember(uint256 _memberIndex) external returns (bool);\n    function retireMember() external returns (bool);\n    function castVote(uint256 _agendaID, uint256 _vote, string calldata _comment) external;\n    function isCandidateContract() external view returns (bool);\n    function totalStaked() external view returns (uint256 totalsupply);\n    function stakedOf(address _account) external view returns (uint256 amount);\n    function setMemo(string calldata _memo) external;\n    function claimActivityReward() external;\n\n    // getter\n    function candidate() external view returns (address);\n    function isLayer2Candidate() external view returns (bool);\n    function memo() external view returns (string memory);\n    function committee() external view returns (address);\n    function seigManager() external view returns (address);\n}\n"
    },
    "contracts/dao/interfaces/ICandidateFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ICandidateFactory {\n    function deploy(\n        address _candidate,\n        bool _isLayer2Candidate,\n        string memory _name,\n        address _committee,\n        address _seigManager\n    )\n        external\n        returns (address);\n}\n"
    },
    "contracts/dao/interfaces/IDAOAgendaManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibAgenda } from \"../lib/Agenda.sol\";\nimport { IDAOCommittee } from \"../interfaces/IDAOCommittee.sol\";\n\ninterface IDAOAgendaManager  {\n    struct Ratio {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    function setCommittee(address _committee) external;\n    function setCreateAgendaFees(uint256 _createAgendaFees) external;\n    function setMinimumNoticePeriodSeconds(uint256 _minimumNoticePeriodSeconds) external;\n    function setMinimumVotingPeriodSeconds(uint256 _minimumVotingPeriodSeconds) external;\n    function setExecutingPeriodSeconds(uint256 _executingPeriodSeconds) external;\n    function newAgenda(\n        address[] memory _targets,\n        uint256 _noticePeriodSeconds,\n        uint256 _votingPeriodSeconds,\n        bool _atomicExecute,\n        bytes[] calldata _functionBytecodes\n    )\n        external\n        returns (uint256 agendaID);\n    function castVote(uint256 _agendaID, address voter, uint256 _vote) external returns (bool);\n    function setExecutedAgenda(uint256 _agendaID) external;\n    function setResult(uint256 _agendaID, LibAgenda.AgendaResult _result) external;\n    function setStatus(uint256 _agendaID, LibAgenda.AgendaStatus _status) external;\n    function endAgendaVoting(uint256 _agendaID) external;\n    function setExecutedCount(uint256 _agendaID, uint256 _count) external;\n\n    // -- view functions\n    function isVoter(uint256 _agendaID, address _user) external view returns (bool);\n    function hasVoted(uint256 _agendaID, address _user) external view returns (bool);\n    function getVoteStatus(uint256 _agendaID, address _user) external view returns (bool, uint256);\n    function getAgendaNoticeEndTimeSeconds(uint256 _agendaID) external view returns (uint256);\n    function getAgendaVotingStartTimeSeconds(uint256 _agendaID) external view returns (uint256);\n    function getAgendaVotingEndTimeSeconds(uint256 _agendaID) external view returns (uint256) ;\n\n    function canExecuteAgenda(uint256 _agendaID) external view returns (bool);\n    function getAgendaStatus(uint256 _agendaID) external view returns (uint256 status);\n    function totalAgendas() external view returns (uint256);\n    function getAgendaResult(uint256 _agendaID) external view returns (uint256 result, bool executed);\n    function getExecutionInfo(uint256 _agendaID)\n        external\n        view\n        returns(\n            address[] memory target,\n            bytes[] memory functionBytecode,\n            bool atomicExecute,\n            uint256 executeStartFrom\n        );\n    function isVotableStatus(uint256 _agendaID) external view returns (bool);\n    function getVotingCount(uint256 _agendaID)\n        external\n        view\n        returns (\n            uint256 countingYes,\n            uint256 countingNo,\n            uint256 countingAbstain\n        );\n    function getAgendaTimestamps(uint256 _agendaID)\n        external\n        view\n        returns (\n            uint256 createdTimestamp,\n            uint256 noticeEndTimestamp,\n            uint256 votingStartedTimestamp,\n            uint256 votingEndTimestamp,\n            uint256 executedTimestamp\n        );\n    function numAgendas() external view returns (uint256);\n    function getVoters(uint256 _agendaID) external view returns (address[] memory);\n\n    function getStatus(uint256 _createAgendaFees) external pure returns (LibAgenda.AgendaStatus);\n\n    // getter\n    function committee() external view returns (IDAOCommittee);\n    function createAgendaFees() external view returns (uint256);\n    function minimumNoticePeriodSeconds() external view returns (uint256);\n    function minimumVotingPeriodSeconds() external view returns (uint256);\n    function executingPeriodSeconds() external view returns (uint256);\n    function agendas(uint256 _index) external view returns (LibAgenda.Agenda memory);\n    function voterInfos(uint256 _index1, address _index2) external view returns (LibAgenda.Voter memory);\n}\n"
    },
    "contracts/dao/interfaces/IDAOCommittee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IStorageStateCommittee } from \"./IStorageStateCommittee.sol\";\n\ninterface IDAOCommittee is IStorageStateCommittee {\n    //--owner\n    function setSeigManager(address _seigManager) external;\n    function setCandidatesSeigManager(address[] calldata _candidateContracts, address _seigManager) external;\n    function setCandidatesCommittee(address[] calldata _candidateContracts, address _committee) external;\n    function setLayer2Registry(address _layer2Registry) external;\n    function setAgendaManager(address _agendaManager) external;\n    function setCandidateFactory(address _candidateFactory) external;\n    function setTon(address _ton) external;\n    function setActivityRewardPerSecond(uint256 _value) external;\n    function setDaoVault(address _daoVault) external;\n\n    function increaseMaxMember(uint256 _newMaxMember, uint256 _quorum) external;\n    function decreaseMaxMember(uint256 _reducingMemberIndex, uint256 _quorum) external;\n    function createCandidate(string calldata _memo) external;\n    function registerLayer2Candidate(address _layer2, string memory _memo) external;\n    function registerLayer2CandidateByOwner(address _operator, address _layer2, string memory _memo) external;\n    function changeMember(uint256 _memberIndex) external returns (bool);\n    function retireMember() external returns (bool);\n    function setMemoOnCandidate(address _candidate, string calldata _memo) external;\n    function setMemoOnCandidateContract(address _candidate, string calldata _memo) external;\n\n    function onApprove(\n        address owner,\n        address spender,\n        uint256 tonAmount,\n        bytes calldata data\n    )\n        external\n        returns (bool);\n\n    function setQuorum(uint256 _quorum) external;\n    function setCreateAgendaFees(uint256 _fees) external;\n    function setMinimumNoticePeriodSeconds(uint256 _minimumNoticePeriod) external;\n    function setMinimumVotingPeriodSeconds(uint256 _minimumVotingPeriod) external;\n    function setExecutingPeriodSeconds(uint256 _executingPeriodSeconds) external;\n    function castVote(uint256 _AgendaID, uint256 _vote, string calldata _comment) external;\n    function endAgendaVoting(uint256 _agendaID) external;\n    function executeAgenda(uint256 _AgendaID) external;\n    function setAgendaStatus(uint256 _agendaID, uint256 _status, uint256 _result) external;\n\n    function updateSeigniorage(address _candidate) external returns (bool);\n    function updateSeigniorages(address[] calldata _candidates) external returns (bool);\n    function claimActivityReward(address _receiver) external;\n\n    function isCandidate(address _candidate) external view returns (bool);\n    function totalSupplyOnCandidate(address _candidate) external view returns (uint256);\n    function balanceOfOnCandidate(address _candidate, address _account) external view returns (uint256);\n    function totalSupplyOnCandidateContract(address _candidateContract) external view returns (uint256);\n    function balanceOfOnCandidateContract(address _candidateContract, address _account) external view returns (uint256);\n    function candidatesLength() external view returns (uint256);\n    function isExistCandidate(address _candidate) external view returns (bool);\n    function getClaimableActivityReward(address _candidate) external view returns (uint256);\n}\n\n"
    },
    "contracts/dao/interfaces/IDAOVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IDAOVault {\n    function setTON(address _ton) external;\n    function setWTON(address _wton) external;\n    function approveTON(address _to, uint256 _amount) external;\n    function approveWTON(address _to, uint256 _amount) external;\n    function approveERC20(address _token, address _to, uint256 _amount) external;\n    function claimTON(address _to, uint256 _amount) external;\n    function claimWTON(address _to, uint256 _amount) external;\n    function claimERC20(address _token, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/dao/interfaces/IERC165A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165A {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/dao/interfaces/ILayer2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ILayer2 {\n  function operator() external view returns (address);\n  function isLayer2() external view returns (bool);\n  function currentFork() external view returns (uint256);\n  function lastEpoch(uint256 forkNumber) external view returns (uint256);\n  function changeOperator(address _operator) external;\n}\n"
    },
    "contracts/dao/interfaces/ILayer2Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ILayer2Registry {\n    function layer2s(address layer2) external view returns (bool);\n\n    function register(address layer2) external returns (bool);\n    function numLayer2s() external view returns (uint256);\n    function layer2ByIndex(uint256 index) external view returns (address);\n\n    function deployCoinage(address layer2, address seigManager) external returns (bool);\n    function registerAndDeployCoinage(address layer2, address seigManager) external returns (bool);\n    function unregister(address layer2) external returns (bool);\n}\n"
    },
    "contracts/dao/interfaces/ISeigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ISeigManager {\n    function registry() external view returns (address);\n    function depositManager() external view returns (address);\n    function ton() external view returns (address);\n    function wton() external view returns (address);\n    function powerton() external view returns (address);\n    function tot() external view returns (address);\n    function coinages(address layer2) external view returns (address);\n    function commissionRates(address layer2) external view returns (uint256);\n\n    function lastCommitBlock(address layer2) external view returns (uint256);\n    function seigPerBlock() external view returns (uint256);\n    function lastSeigBlock() external view returns (uint256);\n    function pausedBlock() external view returns (uint256);\n    function unpausedBlock() external view returns (uint256);\n    function DEFAULT_FACTOR() external view returns (uint256);\n\n    function deployCoinage(address layer2) external returns (bool);\n    function setCommissionRate(address layer2, uint256 commission, bool isCommissionRateNegative) external returns (bool);\n\n    function uncomittedStakeOf(address layer2, address account) external view returns (uint256);\n    function stakeOf(address layer2, address account) external view returns (uint256);\n    function additionalTotBurnAmount(address layer2, address account, uint256 amount) external view returns (uint256 totAmount);\n\n    function onTransfer(address sender, address recipient, uint256 amount) external returns (bool);\n    function updateSeigniorage() external returns (bool);\n    function onDeposit(address layer2, address account, uint256 amount) external returns (bool);\n    function onWithdraw(address layer2, address account, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/dao/interfaces/IStorageStateCommittee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ICandidateFactory } from \"../interfaces/ICandidateFactory.sol\";\nimport { ILayer2Registry } from \"../interfaces/ILayer2Registry.sol\";\nimport { ISeigManager } from \"../interfaces/ISeigManager.sol\";\nimport { IDAOAgendaManager } from \"../interfaces/IDAOAgendaManager.sol\";\nimport { IDAOVault } from \"../interfaces/IDAOVault.sol\";\n\ninterface IStorageStateCommittee {\n    struct CandidateInfo {\n        address candidateContract;\n        uint256 indexMembers;\n        uint128 memberJoinedTime;\n        uint128 rewardPeriod;\n        uint128 claimedTimestamp;\n    }\n\n    function ton() external returns (address);\n    function daoVault() external returns (IDAOVault);\n    function agendaManager() external returns (IDAOAgendaManager);\n    function candidateFactory() external returns (ICandidateFactory);\n    function layer2Registry() external returns (ILayer2Registry);\n    function seigManager() external returns (ISeigManager);\n    function candidates(uint256 _index) external returns (address);\n    function members(uint256 _index) external returns (address);\n    function maxMember() external returns (uint256);\n    function candidateInfos(address _candidate) external returns (CandidateInfo memory);\n    function quorum() external returns (uint256);\n    function activityRewardPerSecond() external returns (uint256);\n\n    function isMember(address _candidate) external returns (bool);\n    function candidateContract(address _candidate) external returns (address);\n}\n\n\n"
    },
    "contracts/dao/interfaces/IWTON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IWTON {\n\n    function onApprove(\n        address owner,\n        address spender,\n        uint256 tonAmount,\n        bytes calldata data\n    ) external returns (bool);\n\n    function swapToTON(uint256 wtonAmount) external returns (bool);\n    function swapToTONAndTransfer(address to, uint256 wtonAmount) external returns (bool);\n    function swapFromTONAndTransfer(address to, uint256 tonAmount) external returns (bool);\n    function renounceTonMinter() external;\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function renounceMinter() external ;\n    function mint(address account, uint256 amount) external returns (bool);\n\n}"
    },
    "contracts/dao/interfaces/Layer2I.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface Layer2I {\n  function operator() external view returns (address);\n  function isLayer2() external view returns (bool);\n  function currentFork() external view returns (uint);\n  function lastEpoch(uint forkNumber) external view returns (uint);\n  function changeOperator(address _operator) external;\n}\n"
    },
    "contracts/dao/interfaces/Layer2RegistryI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface Layer2RegistryI {\n  function layer2s(address layer2) external view returns (bool);\n\n  function register(address layer2) external returns (bool);\n  function numLayer2s() external view returns (uint256);\n  function layer2ByIndex(uint256 index) external view returns (address);\n\n  function deployCoinage(address layer2, address seigManager) external returns (bool);\n  function registerAndDeployCoinage(address layer2, address seigManager) external returns (bool);\n  function unregister(address layer2) external returns (bool);\n}\n"
    },
    "contracts/dao/interfaces/PowerTONI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface PowerTONI {\n  function seigManager() external view returns (address);\n  function wton() external view returns (address);\n\n  function currentRound() external view returns (uint256);\n  function roundDuration() external view returns (uint256);\n  function totalDeposits() external view returns (uint256);\n\n  function winnerOf(uint256 round) external view returns (address);\n  function powerOf(address account) external view returns (uint256);\n\n  function init() external;\n  function start() external;\n  function endRound() external;\n\n  function onDeposit(address layer2, address account, uint256 amount) external;\n  function onWithdraw(address layer2, address account, uint256 amount) external;\n}\n"
    },
    "contracts/dao/lib/Agenda.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibAgenda {\n    //using LibAgenda for Agenda;\n\n    enum AgendaStatus { NONE, NOTICE, VOTING, WAITING_EXEC, EXECUTED, ENDED }\n    enum AgendaResult { PENDING, ACCEPT, REJECT, DISMISS }\n\n    //votor : based operator\n    struct Voter {\n        bool isVoter;\n        bool hasVoted;\n        uint256 vote;\n    }\n\n    // counting abstainVotes yesVotes noVotes\n    struct Agenda {\n        uint256 createdTimestamp;\n        uint256 noticeEndTimestamp;\n        uint256 votingPeriodInSeconds;\n        uint256 votingStartedTimestamp;\n        uint256 votingEndTimestamp;\n        uint256 executableLimitTimestamp;\n        uint256 executedTimestamp;\n        uint256 countingYes;\n        uint256 countingNo;\n        uint256 countingAbstain;\n        AgendaStatus status;\n        AgendaResult result;\n        address[] voters;\n        bool executed;\n    }\n\n    struct AgendaExecutionInfo {\n        address[] targets;\n        bytes[] functionBytecodes;\n        bool atomicExecute;\n        uint256 executeStartFrom;\n    }\n\n    /*function getAgenda(Agenda[] storage agendas, uint256 index) public view returns (Agenda storage agenda) {\n        return agendas[index];\n    }*/\n}\n"
    },
    "contracts/dao/Operator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\n// import \"hardhat/console.sol\";\n\ncontract Operator is AccessibleCommon {\n\n    address public depositManager;\n    address public daoCommiittee;\n    address public layer2;\n    address public ton;\n    address public wton;\n\n    constructor(\n        address depositManager_,\n        address daoCommiittee_,\n        address ton_,\n        address wton_\n    ){\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        depositManager = depositManager_;\n        daoCommiittee = daoCommiittee_;\n        ton = ton_;\n        wton = wton_;\n    }\n\n    function setLayer(address _layer) external onlyOwner {\n        require(layer2 == address(0), \"already set\");\n        require(_layer != address(0), \"zero _layer\");\n        layer2 = _layer;\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount != 0, \"zero amount\");\n\n        (bool success, ) = ton.call(\n            abi.encodeWithSignature(\"approveAndCall(address,uint256,bytes)\", wton, amount, abi.encode(depositManager, layer2))\n        );\n        require(success, 'fail deposit');\n    }\n\n    function execute(address dest, uint256 value, bytes calldata func) external onlyOwner {\n        _call(dest, value, func);\n    }\n\n    /**\n     * execute a sequence of transactions\n     */\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner {\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint256 i = 0; i < dest.length; i++) {\n            _call(dest[i], 0, func[i]);\n        }\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n}\n"
    },
    "contracts/dao/StorageStateCommittee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IStorageStateCommittee } from \"./interfaces/IStorageStateCommittee.sol\";\nimport { ICandidateFactory } from \"./interfaces/ICandidateFactory.sol\";\nimport { ILayer2Registry } from \"./interfaces/ILayer2Registry.sol\";\nimport { ISeigManager } from \"./interfaces/ISeigManager.sol\";\nimport { IDAOAgendaManager } from \"./interfaces/IDAOAgendaManager.sol\";\nimport { IDAOVault } from \"./interfaces/IDAOVault.sol\";\nimport { ICandidate } from \"./interfaces/ICandidate.sol\";\n\ncontract StorageStateCommittee is IStorageStateCommittee {\n    enum AgendaStatus { NONE, NOTICE, VOTING, EXEC, ENDED, PENDING, RISK }\n    enum AgendaResult { UNDEFINED, ACCEPT, REJECT, DISMISS }\n\n    address public override ton;\n    IDAOVault public override daoVault;\n    IDAOAgendaManager public override agendaManager;\n    ICandidateFactory public override candidateFactory;\n    ILayer2Registry public override layer2Registry;\n    ISeigManager public override seigManager;\n\n    address[] public override candidates;\n    address[] public override members;\n    uint256 public override maxMember;\n\n    // candidate EOA => candidate information\n    mapping(address => CandidateInfo) internal _candidateInfos;\n    uint256 public override quorum;\n\n    uint256 public override activityRewardPerSecond;\n\n    modifier validAgendaManager() {\n        require(address(agendaManager) != address(0), \"StorageStateCommittee: AgendaManager is zero\");\n        _;\n    }\n\n    modifier validCommitteeL2Factory() {\n        require(address(candidateFactory) != address(0), \"StorageStateCommittee: invalid CommitteeL2Factory\");\n        _;\n    }\n\n    modifier validLayer2Registry() {\n        require(address(layer2Registry) != address(0), \"StorageStateCommittee: invalid Layer2Registry\");\n        _;\n    }\n\n    modifier validSeigManager() {\n        require(address(seigManager) != address(0), \"StorageStateCommittee: invalid SeigManagere\");\n        _;\n    }\n\n    modifier onlyMember() {\n        require(isMember(msg.sender), \"StorageStateCommittee: not a member\");\n        _;\n    }\n\n    modifier onlyMemberContract() {\n        address candidate = ICandidate(msg.sender).candidate();\n        require(isMember(candidate), \"StorageStateCommittee: not a member\");\n        _;\n    }\n\n    function isMember(address _candidate) public view override returns (bool) {\n        return _candidateInfos[_candidate].memberJoinedTime > 0;\n    }\n\n    function candidateContract(address _candidate) public view override returns (address) {\n        return _candidateInfos[_candidate].candidateContract;\n    }\n\n    function candidateInfos(address _candidate) external override returns (CandidateInfo memory) {\n        return _candidateInfos[_candidate];\n    }\n\n    /*function getCandidate() public view returns (address) {\n        ILayer2(_candidateContract).\n    }*/\n}\n"
    },
    "contracts/dao/StorageStateCommitteeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract StorageStateCommitteeV2 {\n    address internal _implementation;\n    bool public pauseProxy;\n\n    // 마이그레이션 함. 이전 레이어 정보\n    mapping(address => CandidateInfo2) internal _oldCandidateInfos;\n\n    struct CandidateInfo2 {\n        address candidateContract;\n        uint256 indexMembers;\n        uint128 memberJoinedTime;\n        uint128 rewardPeriod;\n        uint128 claimedTimestamp;\n    }\n}"
    },
    "contracts/interfaces/IProxyAction.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\n/// @title IProxyAction\ninterface IProxyAction {\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index\n    /// @param _alive _alive\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external;\n\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        external;\n\n\n    /// @dev set selectors of Implementation\n    /// @param _selectors being added selectors\n    /// @param _imp implementation address\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) external  ;\n\n\n\n    /// onlyOwner\n\n    /// @notice Set pause state\n    /// @param _pause true:pause or false:resume\n    function setProxyPause(bool _pause) external ;\n\n\n    /// anybody\n\n    /// @dev view implementation address of selector of function\n    /// @param _selector selector of function\n    /// @return impl address of the implementation\n    function getSelectorImplementation2(bytes4 _selector)\n        external\n        view\n        returns (address impl);\n\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return address of the implementation\n    function implementation2(uint256 _index) external view returns (address) ;\n}\n\n"
    },
    "contracts/interfaces/IProxyEvent.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\n/// @title IProxyEvent\ninterface IProxyEvent {\n\n    event Upgraded(address indexed implementation);\n\n    event SetAliveImplementation(address indexed impl, bool alive);\n    event SetSelectorImplementation(bytes4 indexed selector, address indexed impl);\n\n\n}\n"
    },
    "contracts/lib/Agenda.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibAgenda {\n    //using LibAgenda for Agenda;\n\n    enum AgendaStatus { NONE, NOTICE, VOTING, WAITING_EXEC, EXECUTED, ENDED }\n    enum AgendaResult { PENDING, ACCEPT, REJECT, DISMISS }\n\n    //votor : based operator\n    struct Voter {\n        bool isVoter;\n        bool hasVoted;\n        uint256 vote;\n    }\n\n    // counting abstainVotes yesVotes noVotes\n    struct Agenda {\n        uint256 createdTimestamp;\n        uint256 noticeEndTimestamp;\n        uint256 votingPeriodInSeconds;\n        uint256 votingStartedTimestamp;\n        uint256 votingEndTimestamp;\n        uint256 executableLimitTimestamp;\n        uint256 executedTimestamp;\n        uint256 countingYes;\n        uint256 countingNo;\n        uint256 countingAbstain;\n        AgendaStatus status;\n        AgendaResult result;\n        address[] voters;\n        bool executed;\n    }\n\n    struct AgendaExecutionInfo {\n        address[] targets;\n        bytes[] functionBytecodes;\n        bool atomicExecute;\n        uint256 executeStartFrom;\n    }\n\n    /*function getAgenda(Agenda[] storage agendas, uint256 index) public view returns (Agenda storage agenda) {\n        return agendas[index];\n    }*/\n}\n"
    },
    "contracts/libraries/DSMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract DSMath {\n  function add(uint x, uint y) internal pure returns (uint z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n  }\n  function sub(uint x, uint y) internal pure returns (uint z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n  }\n  function mul(uint x, uint y) internal pure returns (uint z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n  }\n\n  function min(uint x, uint y) internal pure returns (uint z) {\n    return x <= y ? x : y;\n  }\n  function max(uint x, uint y) internal pure returns (uint z) {\n    return x >= y ? x : y;\n  }\n  function imin(int x, int y) internal pure returns (int z) {\n    return x <= y ? x : y;\n  }\n  function imax(int x, int y) internal pure returns (int z) {\n    return x >= y ? x : y;\n  }\n\n  uint constant WAD_ = 10 ** 18;\n  uint constant RAY_ = 10 ** 27;\n\n  function wmul(uint x, uint y) internal pure returns (uint z) {\n    z = add(mul(x, y), WAD_ / 2) / WAD_;\n  }\n  function rmul(uint x, uint y) internal pure returns (uint z) {\n    z = add(mul(x, y), RAY_ / 2) / RAY_;\n  }\n  function wdiv(uint x, uint y) internal pure returns (uint z) {\n    z = add(mul(x, WAD_), y / 2) / y;\n  }\n  function rdiv(uint x, uint y) internal pure returns (uint z) {\n    z = add(mul(x, RAY_), y / 2) / y;\n  }\n\n  function wmul2(uint x, uint y) internal pure returns (uint z) {\n    z = mul(x, y) / WAD_;\n  }\n  function rmul2(uint x, uint y) internal pure returns (uint z) {\n    z = mul(x, y) / RAY_;\n  }\n  function wdiv2(uint x, uint y) internal pure returns (uint z) {\n    z = mul(x, WAD_) / y;\n  }\n  function rdiv2(uint x, uint y) internal pure returns (uint z) {\n    z = mul(x, RAY_) / y;\n  }\n\n  // This famous algorithm is called \"exponentiation by squaring\"\n  // and calculates x^n with x as fixed-point and n as regular unsigned.\n  //\n  // It's O(log n), instead of O(n) for naive repeated multiplication.\n  //\n  // These facts are why it works:\n  //\n  //  If n is even, then x^n = (x^2)^(n/2).\n  //  If n is odd,  then x^n = x * x^(n-1),\n  //   and applying the equation for even x gives\n  //  x^n = x * (x^2)^((n-1) / 2).\n  //\n  //  Also, EVM division is flooring and\n  //  floor[(n-1) / 2] = floor[n / 2].\n  //\n  function wpow(uint x, uint n) internal pure returns (uint z) {\n    z = n % 2 != 0 ? x : WAD_;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = wmul(x, x);\n\n      if (n % 2 != 0) {\n        z = wmul(z, x);\n      }\n    }\n  }\n\n  function rpow(uint x, uint n) internal pure returns (uint z) {\n    z = n % 2 != 0 ? x : RAY_;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = rmul(x, x);\n\n      if (n % 2 != 0) {\n        z = rmul(z, x);\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev Give an account access to this role.\n   */\n  function add(Role storage role, address account) internal {\n    require(!has(role, account));\n    role.bearer[account] = true;\n  }\n\n  /**\n   * @dev Remove an account's access to this role.\n   */\n  function remove(Role storage role, address account) internal {\n    require(has(role, account));\n    role.bearer[account] = false;\n  }\n\n  /**\n   * @dev Check if an account has this role.\n   * @return bool\n   */\n  function has(Role storage role, address account) internal view returns (bool) {\n    require(account != address(0));\n    return role.bearer[account];\n  }\n}\n"
    },
    "contracts/libraries/SArrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"hardhat/console.sol\";\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary SArrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    function findIndex(uint256[] storage array, uint256 element\n    ) internal view returns (uint256) {\n        if (array.length == 0) return 0;\n       // console.log('findIndex %s %s %s',array.length, array[0], element);\n\n        // Shortcut for the actual value\n        if (element >= array[array.length-1])\n            return (array.length-1);\n        if (element < array[0]) return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = array.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1)/ 2;\n            //console.log('findIndex mid %s %s',mid, array[mid]);\n\n            if (array[mid] <= element) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        //console.log('findIndex return min %s %s',min, array[min]);\n        return min;\n    }\n\n\n\n}\n"
    },
    "contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Proxy is ProxyStorage, AccessibleCommon, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor () {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n\n    /* ========== onlyOwner ========== */\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external override onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/ProxyCoinage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage.sol\";\nimport { AuthControlCoinage } from \"../common/AuthControlCoinage.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract ProxyCoinage is ProxyStorage, AuthControlCoinage, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor () {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(OPERATOR_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n\n\n    /* ========== onlyOwner ========== */\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external override onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/ProxySeigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage.sol\";\nimport { AuthControlSeigManager } from \"../common/AuthControlSeigManager.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract ProxySeigManager is ProxyStorage, AuthControlSeigManager, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor () {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(OPERATOR_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(CHALLENGER_ROLE, MINTER_ROLE);\n    }\n\n    /* ========== onlyOwner ========== */\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external override onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/ProxyStorage.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage  {\n\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n}"
    },
    "contracts/roles/ChallengerRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/Roles.sol\";\n\n\ncontract ChallengerRole {\n  using Roles for Roles.Role;\n\n  event ChallengerAdded(address indexed account);\n  event ChallengerRemoved(address indexed account);\n\n  Roles.Role private _challengers;\n\n  constructor () {\n    _addChallenger(msg.sender);\n  }\n\n  modifier onlyChallenger() {\n    require(isChallenger(msg.sender));\n    _;\n  }\n\n  function isChallenger(address account) public view returns (bool) {\n    return _challengers.has(account);\n  }\n\n  function addChallenger(address account) public onlyChallenger {\n    _addChallenger(account);\n  }\n\n  function renounceChallenger() public {\n    _removeChallenger(msg.sender);\n  }\n\n  function _addChallenger(address account) internal {\n    _challengers.add(account);\n    emit ChallengerAdded(account);\n  }\n\n  function _removeChallenger(address account) internal {\n    _challengers.remove(account);\n    emit ChallengerRemoved(account);\n  }\n}\n"
    },
    "contracts/roles/PauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/Roles.sol\";\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/stake/factory/CoinageFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n// import { AutoRefactorCoinageProxy } from \"../tokens/AutoRefactorCoinageProxy.sol\";\nimport { CoinageFactoryI } from \"../interfaces/CoinageFactoryI.sol\";\nimport { RefactorCoinageSnapshotProxy } from \"../tokens/RefactorCoinageSnapshotProxy.sol\";\n\nimport \"hardhat/console.sol\";\n\n\ninterface IIAutoRefactorCoinage {\n  function initialize (\n      string memory name_,\n      string memory symbol_,\n      uint256 factor_\n    ) external;\n}\n\n\ncontract CoinageFactory is CoinageFactoryI, Ownable {\n  uint256 constant public RAY = 10 ** 27; // 1 RAY\n  uint256 constant internal _DEFAULT_FACTOR = RAY;\n\n  address public autoCoinageLogic;\n\n  function setAutoCoinageLogic(address newLogic) external onlyOwner {\n    autoCoinageLogic = newLogic;\n  }\n\n  function deploy() external override returns (address) {\n    RefactorCoinageSnapshotProxy c = new RefactorCoinageSnapshotProxy();\n    c.upgradeTo(autoCoinageLogic);\n    c.addMinter(msg.sender);\n\n    IIAutoRefactorCoinage(address(c)).initialize(\n      \"StakedWTON\",\n      \"sWTON\",\n      _DEFAULT_FACTOR\n    );\n\n    c.renounceMinter();\n    c.transferOwnership(msg.sender);\n\n    return address(c);\n  }\n}\n"
    },
    "contracts/stake/interfaces/AutoRefactorCoinageI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface AutoRefactorCoinageI {\n  function factor() external view returns (uint256);\n  function setFactor(uint256 factor) external returns (bool);\n  function burn(uint256 amount) external;\n  function burnFrom(address account, uint256 amount) external;\n  function mint(address account, uint256 amount) external returns (bool);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function addMinter(address account) external;\n  function renounceMinter() external;\n  function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/stake/interfaces/CoinageFactoryI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface CoinageFactoryI {\n  function deploy() external returns (address);\n}\n"
    },
    "contracts/stake/interfaces/DepositManagerI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface DepositManagerI {\n  function owner() external view returns (address);\n  function wton() external view returns (address);\n  function registry() external view returns (address);\n  function seigManager() external view returns (address);\n\n  function accStaked(address layer2, address account) external view returns (uint256 wtonAmount);\n  function accStakedLayer2(address layer2) external view returns (uint256 wtonAmount);\n  function accStakedAccount(address account) external view returns (uint256 wtonAmount);\n\n  function pendingUnstaked(address layer2, address account) external view returns (uint256 wtonAmount);\n  function pendingUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount);\n  function pendingUnstakedAccount(address account) external view returns (uint256 wtonAmount);\n\n  function accUnstaked(address layer2, address account) external view returns (uint256 wtonAmount);\n  function accUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount);\n  function accUnstakedAccount(address account) external view returns (uint256 wtonAmount);\n\n\n  function withdrawalRequestIndex(address layer2, address account) external view returns (uint256 index);\n  function withdrawalRequest(address layer2, address account, uint256 index) external view returns (uint128 withdrawableBlockNumber, uint128 amount, bool processed );\n\n  function WITHDRAWAL_DELAY() external view returns (uint256);\n\n  function setSeigManager(address seigManager) external;\n  function deposit(address layer2, uint256 amount) external returns (bool);\n  function requestWithdrawal(address layer2, uint256 amount) external returns (bool);\n  function processRequest(address layer2) external returns (bool);\n  function requestWithdrawalAll(address layer2) external returns (bool);\n  function processRequests(address layer2, uint256 n) external returns (bool);\n\n  function numRequests(address layer2, address account) external view returns (uint256);\n  function numPendingRequests(address layer2, address account) external view returns (uint256);\n\n  function slash(address layer2, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/stake/interfaces/IAutoCoinageSnapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAutoCoinageSnapshot {\n\n    function snapshot() external returns (uint256);\n    function snapshot(address layer2) external returns (uint256) ;\n\n    function sync(address layer2) external returns (uint256);\n    function sync(address layer2, address account) external returns (uint256);\n    function syncBatch(address layer2,  address[] memory accounts) external returns (uint256);\n    function addSync(address layer2, address account) external returns (uint256);\n\n    function getLayer2TotalSupplyInTokamak(address layer2) external view\n        returns (\n                uint256 totalSupplyLayer2,\n                uint256 balance,\n                uint256 refactoredCount,\n                uint256 remain\n        );\n\n    function getLayer2BalanceOfInTokamak(address layer2, address user) external view\n        returns (\n                uint256 balanceOfLayer2Amount,\n                uint256 balance,\n                uint256 refactoredCount,\n                uint256 remain\n        );\n\n    function getBalanceOfInTokamak(address account) external view\n        returns (\n                uint256 accountAmount\n        );\n\n    function getTotalStakedInTokamak() external view\n        returns (\n                uint256 accountAmount\n        );\n\n    function currentAccountBalanceSnapshots(address layer2, address account) external view\n        returns (\n                bool snapshotted,\n                uint256 snapShotBalance,\n                uint256 snapShotRefactoredCount,\n                uint256 snapShotRemain,\n                uint256 currentBalanceOf,\n                uint256 curBalances,\n                uint256 curRefactoredCounts,\n                uint256 curRemains\n        );\n\n    function currentTotalSupplySnapshots(address layer2) external view\n        returns (\n                bool snapshotted,\n                uint256 snapShotBalance,\n                uint256 snapShotRefactoredCount,\n                uint256 snapShotRemain,\n                uint256 currentTotalSupply,\n                uint256 curBalances,\n                uint256 curRefactoredCounts,\n                uint256 curRemains\n        );\n\n    function currentFactorSnapshots(address layer2) external view\n        returns (\n                bool snapshotted,\n                uint256 snapShotFactor,\n                uint256 snapShotRefactorCount,\n                uint256 curFactorValue,\n                uint256 curFactor,\n                uint256 curRefactorCount\n        );\n\n    function getCurrentLayer2SnapshotId(address layer2) external view returns (uint256) ;\n\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address layer2, address account) external view returns (uint256);\n    function balanceOfAt(address account, uint256 snashotAggregatorId) external view returns (uint256);\n    function balanceOfAt(address layer2, address account, uint256 snapshotId) external view returns (uint256);\n    function totalSupply(address layer2) external view returns (uint256);\n    function totalSupplyAt(uint256 snashotAggregatorId) external view returns (uint256 totalStaked);\n    function totalSupplyAt(address layer2, uint256 snapshotId) external view returns (uint256);\n\n}\n"
    },
    "contracts/stake/interfaces/IIERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IIERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function mint(address account, uint256 amount) external;\n\n     /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) external ;\n\n\n    /**\n    * @dev  Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount) external;\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount, bytes memory data)  external;\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount) external ;\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) external ;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) external ;\n\n    function approveAndCall(address spender, uint256 amount, bytes memory data) external returns (bool) ;\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n\n    /**\n    onlyRole(SNAPSHOT_ROLE)\n     */\n    function snapshot() external returns (uint256) ;\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256) ;\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) external view returns (uint256) ;\n\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n}\n"
    },
    "contracts/stake/interfaces/ILockTOSDividend.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n\ninterface ILockTOSDividend {\n    /// @dev Claim batch\n    function claimBatch(address[] calldata _tokens) external;\n\n    /// @dev Claim\n    function claim(address _token) external;\n\n    /// @dev Claim up to `_timestamp`\n    function claimUpTo(address _token, uint256 _timestamp) external;\n\n    /// @dev Epoch to timestamp\n    // function epochToTimestamp(uint256 _epoch) external view returns (uint256);\n\n    /// @dev Distribute\n    // function redistribute(address _token, uint256 _weeklyEpoch) external;\n\n    /// @dev Distribute\n    function distribute(address _token, uint256 _amount) external;\n\n    /// @dev getCurrentWeeklyEpochTimestamp\n    function getCurrentWeeklyEpochTimestamp() external view returns (uint256);\n\n    /// @dev ifDistributionPossible\n    function ifDistributionPossible() external view returns (bool);\n\n    /// @dev getAvailableClaims\n    function getAvailableClaims(address _account) external view returns (address[] memory claimableTokens, uint256[] memory claimableAmounts);\n\n    /// @dev Get weekly epoch for `_timestamp`\n    function getWeeklyEpoch(uint256 _timestamp) external view returns (uint256);\n\n    /// @dev Get current weekly epoch\n    function getCurrentWeeklyEpoch() external view returns (uint256);\n\n    /// @dev Returns tokens per week at `_timestamp`\n    function tokensPerWeekAt(address _token, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns the last epoch claimed for `_lockId`\n    function claimStartWeeklyEpoch(address _token, uint256 _lockId)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns claimable amount\n    function claimable(address _account, address _token) external view returns (uint256);\n\n    /// @dev Returns claimable amount from `_timeStart` to `_timeEnd`\n    function claimableForPeriod(address _account, address _token, uint256 _timeStart, uint256 _timeEnd) external view returns (uint256);\n}"
    },
    "contracts/stake/interfaces/iPowerTON.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ninterface iPowerTON {\n  //function seigManager() external view returns (address);\n  //function wton() external view returns (address);\n\n  function currentRound() external view returns (uint256);\n  function roundDuration() external view returns (uint256);\n  function totalDeposits() external view returns (uint256);\n\n  function winnerOf(uint256 round) external view returns (address);\n  function powerOf(address account) external view returns (uint256);\n\n  function init() external;\n  function start() external;\n  function endRound() external;\n\n  function onDeposit(address layer2, address account, uint256 amount) external;\n  function onWithdraw(address layer2, address account, uint256 amount) external;\n}\n"
    },
    "contracts/stake/interfaces/IPowerTONSwapperEvent.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ninterface IPowerTONSwapperEvent {\n    event OnDeposit(address layer2, address indexed account, uint256 amount);\n    event OnWithdraw(address layer2, address indexed account, uint256 amount);\n\n    event Swapped(\n        uint256 amount\n    );\n\n    event Distributed(address token, uint256 amount);\n}\n"
    },
    "contracts/stake/interfaces/ITOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ITOS {\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @dev Issue a token.\n    /// @param to  who takes the issue\n    /// @param amount the amount to issue\n    function mint(address to, uint256 amount) external returns (bool);\n\n    // @dev burn a token.\n    /// @param from Whose tokens are burned\n    /// @param amount the amount to burn\n    function burn(address from, uint256 amount) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    /// @dev Authorizes the owner's token to be used by the spender as much as the value.\n    /// @dev The signature must have the owner's signature.\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param v the owner's signature - v\n    /// @param r the owner's signature - r\n    /// @param s the owner's signature - s\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @dev verify the signature\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    /// @param sigR the owner's signature - r\n    /// @param sigS the owner's signature - s\n    /// @param sigV the owner's signature - v\n    function verify(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external view returns (bool);\n\n    /// @dev the hash of Permit\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    function hashPermit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce\n    ) external view returns (bytes32);\n}"
    },
    "contracts/stake/interfaces/SeigManagerI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface SeigManagerI {\n  function registry() external view returns (address);\n  function depositManager() external view returns (address);\n  function ton() external view returns (address);\n  function wton() external view returns (address);\n  function powerton() external view returns (address);\n  function tot() external view returns (address);\n  function coinages(address layer2) external view returns (address);\n  function commissionRates(address layer2) external view returns (uint256);\n\n  function lastCommitBlock(address layer2) external view returns (uint256);\n  function seigPerBlock() external view returns (uint256);\n  function lastSeigBlock() external view returns (uint256);\n  function pausedBlock() external view returns (uint256);\n  function unpausedBlock() external view returns (uint256);\n  function DEFAULT_FACTOR() external view returns (uint256);\n\n  function deployCoinage(address layer2) external returns (bool);\n  function setCommissionRate(address layer2, uint256 commission, bool isCommissionRateNegative) external returns (bool);\n\n  function uncomittedStakeOf(address layer2, address account) external view returns (uint256);\n  function stakeOf(address layer2, address account) external view returns (uint256);\n  function additionalTotBurnAmount(address layer2, address account, uint256 amount) external view returns (uint256 totAmount);\n\n  function onTransfer(address sender, address recipient, uint256 amount) external returns (bool);\n  function updateSeigniorage() external returns (bool);\n  function onDeposit(address layer2, address account, uint256 amount) external returns (bool);\n  function onWithdraw(address layer2, address account, uint256 amount) external returns (bool);\n\n}\n"
    },
    "contracts/stake/Layer2Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { Layer2RegistryI } from \"../dao/interfaces/Layer2RegistryI.sol\";\n\nimport \"../proxy/ProxyStorage.sol\";\nimport { AuthControlCoinage } from \"../common/AuthControlCoinage.sol\";\nimport { Layer2RegistryStorage } from \"./Layer2RegistryStorage.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface IISeigManager {\n  function deployCoinage(address layer2) external returns (bool);\n  function setCommissionRate(address layer2, uint256 commission, bool isCommissionRateNegative) external returns (bool);\n}\n\ninterface IILayer2 {\n  function operator() external view returns (address);\n  function isLayer2() external view returns (bool);\n}\n\n// TODO: transfer coinages ownership to seig manager\ncontract Layer2Registry is  ProxyStorage, AuthControlCoinage, Layer2RegistryStorage, Layer2RegistryI {\n\n  modifier onlyMinterOrOperator(address layer2) {\n    require(hasRole(MINTER_ROLE, msg.sender) || IILayer2(layer2).operator() == msg.sender, \"sender is neither admin nor operator\");\n    _;\n  }\n\n  // ------ onlyOwner\n\n  function deployCoinage(\n    address layer2,\n    address seigManager\n  )\n    external\n    onlyMinterOrOperator(layer2) override\n    returns (bool)\n  {\n    return _deployCoinage(layer2, seigManager);\n  }\n\n  function registerAndDeployCoinage(\n    address layer2,\n    address seigManager\n  )\n    external\n    onlyMinterOrOperator(layer2) override\n    returns (bool)\n  {\n    require(_register(layer2));\n    require(_deployCoinage(layer2, seigManager));\n    return true;\n  }\n\n  function registerAndDeployCoinageAndSetCommissionRate(\n    address layer2,\n    address seigManager,\n    uint256 commissionRate,\n    bool isCommissionRateNegative\n  )\n    external\n    onlyMinterOrOperator(layer2)\n    returns (bool)\n  {\n    require(_register(layer2));\n    require(_deployCoinage(layer2, seigManager));\n    require(_setCommissionRate(layer2, seigManager, commissionRate, isCommissionRateNegative));\n    return true;\n  }\n\n  function register(address layer2)\n    external\n    onlyMinterOrOperator(layer2)  override\n    returns (bool)\n  {\n    return _register(layer2);\n  }\n\n  function unregister(address layer2) external onlyOwner returns (bool) {\n    require(_layer2s[layer2]);\n\n    _layer2s[layer2] = false;\n    return true;\n  }\n\n\n  // ------ external\n\n  function layer2s(address layer2) external view override returns (bool) {\n    return _layer2s[layer2];\n  }\n\n  function numLayer2s() external view  override returns (uint256) {\n    return _numLayer2s;\n  }\n\n  function layer2ByIndex(uint256 index) external view override returns (address) {\n    return _layer2ByIndex[index];\n  }\n\n  // ------ internal\n\n  function _register(address layer2) internal returns (bool) {\n    require(!_layer2s[layer2]);\n    require(IILayer2(layer2).isLayer2());\n\n    _layer2s[layer2] = true;\n    _layer2ByIndex[_numLayer2s] = layer2;\n    _numLayer2s += 1;\n\n    return true;\n  }\n\n  function _deployCoinage(\n    address layer2,\n    address seigManager\n  )\n   internal\n   returns (bool)\n  {\n    return IISeigManager(seigManager).deployCoinage(layer2);\n  }\n\n  function _setCommissionRate(\n    address layer2,\n    address seigManager,\n    uint256 commissionRate,\n    bool isCommissionRateNegative\n  )\n    internal\n    returns (bool)\n  {\n    return IISeigManager(seigManager).setCommissionRate(layer2, commissionRate, isCommissionRateNegative);\n  }\n\n}\n"
    },
    "contracts/stake/Layer2RegistryProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/ProxyCoinage.sol\";\nimport \"./Layer2RegistryStorage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract Layer2RegistryProxy is ProxyCoinage, Layer2RegistryStorage {\n\n}\n"
    },
    "contracts/stake/Layer2RegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract Layer2RegistryStorage   {\n\n    // check whether the address is layer2 contract or not\n    mapping (address => bool) internal _layer2s;\n\n    // array-like storages\n    // NOTE: unregistered layer2s could exists in that array. so, should check by layer2s(address)\n    uint256 internal _numLayer2s;\n    mapping (uint256 => address) internal _layer2ByIndex;\n\n}\n"
    },
    "contracts/stake/managers/DepositManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IWTON } from \"../../dao/interfaces/IWTON.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\nimport { DepositManagerStorage } from \"./DepositManagerStorage.sol\";\n\ninterface IOnApprove {\n  function onApprove(address owner, address spender, uint256 amount, bytes calldata data) external returns (bool);\n}\n\ninterface ILayer2Registry {\n  function layer2s(address layer2) external view returns (bool);\n}\n\ninterface ILayer2 {\n  function operator() external view returns (address);\n}\n\ninterface ISeigManager {\n  function stakeOf(address layer2, address account) external view returns (uint256);\n  function onDeposit(address layer2, address account, uint256 amount) external returns (bool);\n  function onWithdraw(address layer2, address account, uint256 amount) external returns (bool);\n}\n\n/**\n * @dev DepositManager manages WTON deposit and withdrawal from operator and WTON holders.\n */\n//ERC165\ncontract DepositManager is ProxyStorage, AccessibleCommon, DepositManagerStorage {\n  using SafeERC20 for IERC20;\n\n  ////////////////////\n  // Modifiers\n  ////////////////////\n\n  modifier onlyLayer2(address layer2) {\n    require(ILayer2Registry(_registry).layer2s(layer2));\n    _;\n  }\n\n  modifier onlySeigManager() {\n    require(msg.sender == _seigManager);\n    _;\n  }\n\n  ////////////////////\n  // Events\n  ////////////////////\n\n  event Deposited(address indexed layer2, address depositor, uint256 amount);\n  event WithdrawalRequested(address indexed layer2, address depositor, uint256 amount);\n  event WithdrawalProcessed(address indexed layer2, address depositor, uint256 amount);\n\n  function initialize (\n    address wton_,\n    address registry_,\n    address seigManager_,\n    uint256 globalWithdrawalDelay_\n  ) external {\n    require(_wton == address(0), \"already initialized\");\n\n    _wton = wton_;\n    _registry = registry_;\n    _seigManager = seigManager_;\n    globalWithdrawalDelay = globalWithdrawalDelay_;\n    _registerInterface(IOnApprove.onApprove.selector);\n  }\n\n  ////////////////////\n  // SeiManager function\n  ////////////////////\n\n  function setSeigManager(address seigManager_) external onlyOwner {\n    _seigManager = seigManager_;\n  }\n\n  ////////////////////\n  // ERC20 Approve callback\n  ////////////////////\n\n  function onApprove(\n    address owner,\n    address spender,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bool) {\n    require(msg.sender == _wton, \"DepositManager: only accept WTON approve callback\");\n\n    address layer2 = _decodeDepositManagerOnApproveData(data);\n    require(_deposit(layer2, owner, amount, owner));\n\n    return true;\n  }\n\n  function _decodeDepositManagerOnApproveData(\n    bytes memory data\n  ) internal pure returns (address layer2) {\n    require(data.length == 0x20);\n\n    assembly {\n      layer2 := mload(add(data, 0x20))\n    }\n  }\n\n  ////////////////////\n  // Deposit function\n  ////////////////////\n\n  /**\n   * @dev deposit `amount` WTON in RAY\n   */\n\n  function deposit(address layer2, uint256 amount) external returns (bool) {\n    require(_deposit(layer2, msg.sender, amount));\n    return true;\n  }\n\n  function deposit(address layer2, address account, uint256 amount) external returns (bool) {\n    require(_deposit(layer2, account, amount, msg.sender));\n    return true;\n  }\n\n  function deposit(address layer2, address[] memory accounts, uint256[] memory amounts) external returns (bool) {\n    require(accounts.length != 0, 'no account');\n    require(accounts.length == amounts.length, 'wrong lenth');\n\n    for (uint256 i = 0; i < accounts.length; i++){\n      require(accounts[i] != address(0) && amounts[i] != 0, \"zero amount or zero address\");\n      require(_deposit(layer2, accounts[i], amounts[i], msg.sender));\n    }\n\n    return true;\n  }\n\n  function _deposit(address layer2, address account, uint256 amount) internal onlyLayer2(layer2) returns (bool) {\n     return _deposit(layer2, account, amount, account);\n  }\n\n  function _deposit(address layer2, address account, uint256 amount, address payer) internal onlyLayer2(layer2) returns (bool) {\n    _accStaked[layer2][account] = _accStaked[layer2][account] + amount;\n    _accStakedLayer2[layer2] = _accStakedLayer2[layer2] + amount;\n    _accStakedAccount[account] = _accStakedAccount[account] + amount;\n\n    IERC20(_wton).safeTransferFrom(payer, address(this), amount);\n\n    emit Deposited(layer2, account, amount);\n\n    require(ISeigManager(_seigManager).onDeposit(layer2, account, amount));\n\n    return true;\n  }\n\n  ////////////////////\n  // Re-deposit function\n  ////////////////////\n\n  /**\n   * @dev re-deposit pending requests in the pending queue\n   */\n\n  function redeposit(address layer2) external returns (bool) {\n    uint256 i = _withdrawalRequestIndex[layer2][msg.sender];\n    require(_redeposit(layer2, i, 1));\n    return true;\n  }\n\n  function redepositMulti(address layer2, uint256 n) external returns (bool) {\n    uint256 i = _withdrawalRequestIndex[layer2][msg.sender];\n    require(_redeposit(layer2, i, n));\n    return true;\n  }\n\n  function _redeposit(address layer2, uint256 i, uint256 n) internal onlyLayer2(layer2) returns (bool) {\n    uint256 accAmount;\n\n    require(_withdrawalRequests[layer2][msg.sender].length > 0, \"DepositManager: no request\");\n    require(_withdrawalRequests[layer2][msg.sender].length - i >= n, \"DepositManager: n exceeds num of pending requests\");\n\n    uint256 e = i + n;\n    for (; i < e; i++) {\n      WithdrawalReqeust storage r = _withdrawalRequests[layer2][msg.sender][i];\n      uint256 amount = r.amount;\n\n      require(!r.processed, \"DepositManager: pending request already processed\");\n      require(amount > 0, \"DepositManager: no valid pending request\");\n\n      accAmount = accAmount + amount;\n      r.processed = true;\n    }\n\n\n    // deposit-related storages\n    _accStaked[layer2][msg.sender] = _accStaked[layer2][msg.sender] + accAmount;\n    _accStakedLayer2[layer2] = _accStakedLayer2[layer2] + accAmount;\n    _accStakedAccount[msg.sender] = _accStakedAccount[msg.sender] + accAmount;\n\n    // withdrawal-related storages\n    _pendingUnstaked[layer2][msg.sender] = _pendingUnstaked[layer2][msg.sender] - accAmount;\n    _pendingUnstakedLayer2[layer2] = _pendingUnstakedLayer2[layer2] - accAmount;\n    _pendingUnstakedAccount[msg.sender] = _pendingUnstakedAccount[msg.sender] - accAmount;\n\n    _withdrawalRequestIndex[layer2][msg.sender] += n;\n\n    emit Deposited(layer2, msg.sender, accAmount);\n\n    require(ISeigManager(_seigManager).onDeposit(layer2, msg.sender, accAmount));\n\n    return true;\n  }\n\n  ////////////////////\n  // Slash functions\n  ////////////////////\n\n  function slash(address layer2, address recipient, uint256 amount) external onlySeigManager returns (bool) {\n    //return _wton.transferFrom(owner, recipient, amount);\n  }\n\n  ////////////////////\n  // Setter\n  ////////////////////\n\n  function setGlobalWithdrawalDelay(uint256 globalWithdrawalDelay_) external onlyOwner {\n    globalWithdrawalDelay = globalWithdrawalDelay_;\n  }\n\n  function setWithdrawalDelay(address l2chain, uint256 withdrawalDelay_) external {\n    require(_isOperator(l2chain, msg.sender));\n    withdrawalDelay[l2chain] = withdrawalDelay_;\n  }\n\n  ////////////////////\n  // Withdrawal functions\n  ////////////////////\n\n  function requestWithdrawal(address layer2, uint256 amount) external returns (bool) {\n    return _requestWithdrawal(layer2, amount);\n  }\n\n  function _requestWithdrawal(address layer2, uint256 amount) internal onlyLayer2(layer2) returns (bool) {\n    require(amount > 0, \"DepositManager: amount must not be zero\");\n\n    uint256 delay = globalWithdrawalDelay > withdrawalDelay[layer2] ? globalWithdrawalDelay : withdrawalDelay[layer2];\n    _withdrawalRequests[layer2][msg.sender].push(WithdrawalReqeust({\n      withdrawableBlockNumber: uint128(block.number + delay),\n      amount: uint128(amount),\n      processed: false\n    }));\n\n    _pendingUnstaked[layer2][msg.sender] = _pendingUnstaked[layer2][msg.sender] + amount;\n    _pendingUnstakedLayer2[layer2] = _pendingUnstakedLayer2[layer2] + amount;\n    _pendingUnstakedAccount[msg.sender] = _pendingUnstakedAccount[msg.sender] + amount;\n\n    emit WithdrawalRequested(layer2, msg.sender, amount);\n\n    require(ISeigManager(_seigManager).onWithdraw(layer2, msg.sender, amount));\n\n    return true;\n  }\n\n  function processRequest(address layer2, bool receiveTON) external returns (bool) {\n    return _processRequest(layer2, receiveTON);\n  }\n\n  function _processRequest(address layer2, bool receiveTON) internal returns (bool) {\n    uint256 index = _withdrawalRequestIndex[layer2][msg.sender];\n    require(_withdrawalRequests[layer2][msg.sender].length > index, \"DepositManager: no request to process\");\n\n    WithdrawalReqeust storage r = _withdrawalRequests[layer2][msg.sender][index];\n\n    require(r.withdrawableBlockNumber <= block.number, \"DepositManager: wait for withdrawal delay\");\n    r.processed = true;\n\n    _withdrawalRequestIndex[layer2][msg.sender] += 1;\n\n    uint256 amount = r.amount;\n\n    _pendingUnstaked[layer2][msg.sender] = _pendingUnstaked[layer2][msg.sender] - amount;\n    _pendingUnstakedLayer2[layer2] = _pendingUnstakedLayer2[layer2] - amount;\n    _pendingUnstakedAccount[msg.sender] = _pendingUnstakedAccount[msg.sender] - amount;\n\n    _accUnstaked[layer2][msg.sender] = _accUnstaked[layer2][msg.sender] + amount;\n    _accUnstakedLayer2[layer2] = _accUnstakedLayer2[layer2] + amount;\n    _accUnstakedAccount[msg.sender] = _accUnstakedAccount[msg.sender] + amount;\n\n    if (receiveTON) {\n      require(IWTON(_wton).swapToTONAndTransfer(msg.sender, amount));\n    } else {\n      IERC20(_wton).safeTransfer(msg.sender, amount);\n    }\n\n    emit WithdrawalProcessed(layer2, msg.sender, amount);\n    return true;\n  }\n\n  function requestWithdrawalAll(address layer2) external onlyLayer2(layer2) returns (bool) {\n    uint256 amount = ISeigManager(_seigManager).stakeOf(layer2, msg.sender);\n\n    return _requestWithdrawal(layer2, amount);\n  }\n\n  function processRequests(address layer2, uint256 n, bool receiveTON) external returns (bool) {\n    for (uint256 i = 0; i < n; i++) {\n      require(_processRequest(layer2, receiveTON));\n    }\n    return true;\n  }\n\n  function numRequests(address layer2, address account) external view returns (uint256) {\n    return _withdrawalRequests[layer2][account].length;\n  }\n\n  function numPendingRequests(address layer2, address account) external view returns (uint256) {\n    uint256 numRequests_ = _withdrawalRequests[layer2][account].length;\n    uint256 index = _withdrawalRequestIndex[layer2][account];\n\n    if (numRequests_ == 0) return 0;\n\n    return numRequests_ - index;\n  }\n\n  function _isOperator(address layer2, address operator) internal view returns (bool) {\n    return operator == ILayer2(layer2).operator();\n  }\n\n\n  ////////////////////\n  // Storage getters\n  ////////////////////\n\n  // solium-disable\n  function wton() external view returns (address) { return _wton; }\n  function registry() external view returns (address) { return _registry; }\n  function seigManager() external view returns (address) { return _seigManager; }\n\n  function accStaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _accStaked[layer2][account]; }\n  function accStakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _accStakedLayer2[layer2]; }\n  function accStakedAccount(address account) external view returns (uint256 wtonAmount) { return _accStakedAccount[account]; }\n\n  function pendingUnstaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _pendingUnstaked[layer2][account]; }\n  function pendingUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _pendingUnstakedLayer2[layer2]; }\n  function pendingUnstakedAccount(address account) external view returns (uint256 wtonAmount) { return _pendingUnstakedAccount[account]; }\n\n  function accUnstaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _accUnstaked[layer2][account]; }\n  function accUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _accUnstakedLayer2[layer2]; }\n  function accUnstakedAccount(address account) external view returns (uint256 wtonAmount) { return _accUnstakedAccount[account]; }\n\n  function withdrawalRequestIndex(address layer2, address account) external view returns (uint256 index) { return _withdrawalRequestIndex[layer2][account]; }\n  function withdrawalRequest(address layer2, address account, uint256 index) external view returns (uint128 withdrawableBlockNumber, uint128 amount, bool processed ) {\n    withdrawableBlockNumber = _withdrawalRequests[layer2][account][index].withdrawableBlockNumber;\n    amount = _withdrawalRequests[layer2][account][index].amount;\n    processed = _withdrawalRequests[layer2][account][index].processed;\n  }\n\n  // solium-enable\n}\n"
    },
    "contracts/stake/managers/DepositManagerForMigration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IWTON } from \"../../dao/interfaces/IWTON.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\nimport { DepositManagerStorage } from \"./DepositManagerStorage.sol\";\n\ninterface IOnApprove {\n  function onApprove(address owner, address spender, uint256 amount, bytes calldata data) external returns (bool);\n}\n\ninterface ILayer2Registry {\n  function layer2s(address layer2) external view returns (bool);\n}\n\ninterface ILayer2 {\n  function operator() external view returns (address);\n}\n\ninterface ISeigManager {\n  function stakeOf(address layer2, address account) external view returns (uint256);\n  function onDeposit(address layer2, address account, uint256 amount) external returns (bool);\n  function onWithdraw(address layer2, address account, uint256 amount) external returns (bool);\n}\n\n/**\n * @dev DepositManager manages WTON deposit and withdrawal from operator and WTON holders.\n */\n//ERC165\ncontract DepositManagerForMigration is ProxyStorage, AccessibleCommon, DepositManagerStorage {\n  using SafeERC20 for IERC20;\n\n  ////////////////////\n  // Modifiers\n  ////////////////////\n\n  modifier onlyLayer2(address layer2) {\n    require(ILayer2Registry(_registry).layer2s(layer2));\n    _;\n  }\n\n  modifier onlySeigManager() {\n    require(msg.sender == _seigManager);\n    _;\n  }\n\n  ////////////////////\n  // Events\n  ////////////////////\n\n  event Deposited(address indexed layer2, address depositor, uint256 amount);\n  event WithdrawalRequested(address indexed layer2, address depositor, uint256 amount);\n  event WithdrawalProcessed(address indexed layer2, address depositor, uint256 amount);\n\n  // ---------  onlyOwner\n\n  function initialize (\n    address wton_,\n    address registry_,\n    uint256 globalWithdrawalDelay_\n  ) external onlyOwner {\n\n    require(_wton == address(0), \"already initialized\");\n\n    _wton = wton_;\n    _registry = registry_;\n    globalWithdrawalDelay = globalWithdrawalDelay_;\n    _registerInterface(IOnApprove.onApprove.selector);\n  }\n\n  function setSeigManager(address seigManager_) external onlyOwner {\n    _seigManager = seigManager_;\n  }\n\n  function depositWithoutTransfer(address layer2, address[] memory accounts, uint256[] memory amounts)\n    external onlyOwner returns (bool) {\n    require(accounts.length != 0, 'no account');\n    require(accounts.length == amounts.length, 'wrong lenth');\n\n    for (uint256 i = 0; i < accounts.length; i++){\n      require(accounts[i] != address(0) && amounts[i] != 0, \"zero amount or zero address\");\n      require(_deposit(layer2, accounts[i], amounts[i]));\n    }\n\n    return true;\n  }\n\n  function setGlobalWithdrawalDelay(uint256 globalWithdrawalDelay_) external onlyOwner {\n    globalWithdrawalDelay = globalWithdrawalDelay_;\n  }\n\n  // ---------  external\n\n\n  // --------- internal\n\n  function _deposit(address layer2, address account, uint256 amount) internal onlyLayer2(layer2) returns (bool) {\n    _accStaked[layer2][account] = _accStaked[layer2][account] + amount;\n    _accStakedLayer2[layer2] = _accStakedLayer2[layer2] + amount;\n    _accStakedAccount[account] = _accStakedAccount[account] + amount;\n\n    // IERC20(_wton).safeTransferFrom(payer, address(this), amount);\n\n    emit Deposited(layer2, account, amount);\n\n    require(ISeigManager(_seigManager).onDeposit(layer2, account, amount));\n\n    return true;\n  }\n\n\n  function _isOperator(address layer2, address operator) internal view returns (bool) {\n    return operator == ILayer2(layer2).operator();\n  }\n\n\n  ////////////////////\n  // Storage getters\n  ////////////////////\n\n  // solium-disable\n  function wton() external view returns (address) { return _wton; }\n  function registry() external view returns (address) { return _registry; }\n  function seigManager() external view returns (address) { return _seigManager; }\n\n  function accStaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _accStaked[layer2][account]; }\n  function accStakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _accStakedLayer2[layer2]; }\n  function accStakedAccount(address account) external view returns (uint256 wtonAmount) { return _accStakedAccount[account]; }\n\n  function pendingUnstaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _pendingUnstaked[layer2][account]; }\n  function pendingUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _pendingUnstakedLayer2[layer2]; }\n  function pendingUnstakedAccount(address account) external view returns (uint256 wtonAmount) { return _pendingUnstakedAccount[account]; }\n\n  function accUnstaked(address layer2, address account) external view returns (uint256 wtonAmount) { return _accUnstaked[layer2][account]; }\n  function accUnstakedLayer2(address layer2) external view returns (uint256 wtonAmount) { return _accUnstakedLayer2[layer2]; }\n  function accUnstakedAccount(address account) external view returns (uint256 wtonAmount) { return _accUnstakedAccount[account]; }\n\n  function withdrawalRequestIndex(address layer2, address account) external view returns (uint256 index) { return _withdrawalRequestIndex[layer2][account]; }\n  function withdrawalRequest(address layer2, address account, uint256 index) external view returns (uint128 withdrawableBlockNumber, uint128 amount, bool processed ) {\n    withdrawableBlockNumber = _withdrawalRequests[layer2][account][index].withdrawableBlockNumber;\n    amount = _withdrawalRequests[layer2][account][index].amount;\n    processed = _withdrawalRequests[layer2][account][index].processed;\n  }\n\n  // solium-enable\n}\n"
    },
    "contracts/stake/managers/DepositManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/Proxy.sol\";\nimport \"./DepositManagerStorage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract DepositManagerProxy is Proxy, DepositManagerStorage {\n\n}\n"
    },
    "contracts/stake/managers/DepositManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract DepositManagerStorage   {\n    ////////////////////\n    // Storage - contracts\n    ////////////////////\n\n    address internal _wton;\n    address internal _registry;\n    address internal _seigManager;\n\n    ////////////////////\n    // Storage - token amount\n    ////////////////////\n\n    // accumulated staked amount\n    // layer2 => msg.sender => wton amount\n    mapping (address => mapping (address => uint256)) internal _accStaked;\n    // layer2 => wton amount\n    mapping (address => uint256) internal _accStakedLayer2;\n    // msg.sender => wton amount\n    mapping (address => uint256) internal _accStakedAccount;\n\n    // pending unstaked amount\n    // layer2 => msg.sender => wton amount\n    mapping (address => mapping (address => uint256)) internal _pendingUnstaked;\n    // layer2 => wton amount\n    mapping (address => uint256) internal _pendingUnstakedLayer2;\n    // msg.sender => wton amount\n    mapping (address => uint256) internal _pendingUnstakedAccount;\n\n    // accumulated unstaked amount\n    // layer2 => msg.sender => wton amount\n    mapping (address => mapping (address => uint256)) internal _accUnstaked;\n    // layer2 => wton amount\n    mapping (address => uint256) internal _accUnstakedLayer2;\n    // msg.sender => wton amount\n    mapping (address => uint256) internal _accUnstakedAccount;\n\n    // layer2 => msg.sender => withdrawal requests\n    mapping (address => mapping (address => WithdrawalReqeust[])) internal _withdrawalRequests;\n\n    // layer2 => msg.sender => index\n    mapping (address => mapping (address => uint256)) internal _withdrawalRequestIndex;\n\n    ////////////////////\n    // Storage - configuration / ERC165 interfaces\n    ////////////////////\n\n    // withdrawal delay in block number\n    // @TODO: change delay unit to CYCLE?\n    uint256 public globalWithdrawalDelay;\n    mapping (address => uint256) public withdrawalDelay;\n\n    struct WithdrawalReqeust {\n        uint128 withdrawableBlockNumber;\n        uint128 amount;\n        bool processed;\n    }\n}\n"
    },
    "contracts/stake/managers/SeigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { DSMath } from \"../../libraries/DSMath.sol\";\nimport { AutoRefactorCoinageI } from \"../interfaces/AutoRefactorCoinageI.sol\";\nimport { CoinageFactoryI } from \"../../dao/interfaces/CoinageFactoryI.sol\";\nimport { IWTON } from \"../../dao/interfaces/IWTON.sol\";\nimport { Layer2I } from \"../../dao/interfaces/Layer2I.sol\";\nimport { SeigManagerI } from \"../interfaces/SeigManagerI.sol\";\n\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AuthControlSeigManager } from \"../../common/AuthControlSeigManager.sol\";\nimport { SeigManagerStorage } from \"./SeigManagerStorage.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface MinterRoleRenounceTarget {\n  function renounceMinter() external;\n}\n\ninterface PauserRoleRenounceTarget {\n  function renouncePauser() external;\n}\n\ninterface OwnableTarget {\n  function renounceOwnership() external;\n  function transferOwnership(address newOwner) external;\n}\n\ninterface IILayer2Registry {\n  function layer2s(address layer2) external view returns (bool);\n}\n\ninterface IPowerTON {\n  function onDeposit(address layer2, address account, uint256 amount) external;\n  function onWithdraw(address layer2, address account, uint256 amount) external;\n}\n\ninterface ITON {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n}\n\n/**\n * @dev SeigManager gives seigniorage to operator and WTON holders.\n * For each commit by operator, operator (or user) will get seigniorage\n * in propotion to the staked (or delegated) amount of WTON.\n *\n * [Tokens]\n * - {tot} tracks total staked or delegated WTON of each Layer2 contract (and depositor?).\n * - {coinages[layer2]} tracks staked or delegated WTON of user or operator to a Layer2 contract.\n *\n * For each commit by operator,\n *  1. increases all layer2's balance of {tot} by (the staked amount of WTON) /\n *     (total supply of TON and WTON) * (num blocks * seigniorage per block).\n *  2. increases all depositors' blanace of {coinages[layer2]} in proportion to the staked amount of WTON,\n *     up to the increased amount in step (1).\n *  3. set the layer2's balance of {committed} as the layer2's {tot} balance.\n *\n * For each stake or delegate with amount of {v} to a Layer2,\n *  1. mint {v} {coinages[layer2]} tokens to the account\n *  2. mint {v} {tot} tokens to the layer2 contract\n *\n * For each unstake or undelegate (or get rewards) with amount of {v} to a Layer2,\n *  1. burn {v} {coinages[layer2]} tokens from the account\n *  2. burn {v + ⍺} {tot} tokens from the layer2 contract,\n *   where ⍺ = SEIGS * staked ratio of the layer2 * withdrawal ratio of the account\n *     - SEIGS                              = tot total supply - tot total supply at last commit from the layer2\n *     - staked ratio of the layer2     = tot balance of the layer2 / tot total supply\n *     - withdrawal ratio of the account  = amount to withdraw / total supply of coinage\n *\n */\ncontract SeigManager is ProxyStorage, AuthControlSeigManager, SeigManagerStorage, SeigManagerI, DSMath {\n\n  //////////////////////////////\n  // Modifiers\n  //////////////////////////////\n\n  modifier onlyRegistry() {\n    require(msg.sender == _registry, \"not onlyRegistry\");\n    _;\n  }\n\n  modifier onlyRegistryOrOperator(address layer2) {\n    require(msg.sender == _registry || msg.sender == Layer2I(layer2).operator(), \"not onlyRegistryOrOperator\");\n    _;\n  }\n\n  modifier onlyDepositManager() {\n    require(msg.sender == _depositManager, \"not onlyDepositManager\");\n    _;\n  }\n\n  modifier onlyLayer2(address layer2) {\n    require(IILayer2Registry(_registry).layer2s(layer2), \"not onlyLayer2\");\n    _;\n  }\n\n  modifier checkCoinage(address layer2) {\n    require(address(_coinages[layer2]) != address(0), \"SeigManager: coinage has not been deployed yet\");\n    _;\n  }\n\n  modifier whenNotPaused() {\n      require(!paused, \"Pausable: paused\");\n      _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n      require(paused, \"Pausable: not paused\");\n      _;\n  }\n\n\n  //////////////////////////////\n  // Events\n  //////////////////////////////\n\n  event CoinageCreated(address indexed layer2, address coinage);\n  event SeigGiven(address indexed layer2, uint256 totalSeig, uint256 stakedSeig, uint256 unstakedSeig, uint256 powertonSeig, uint256 pseig);\n  event Comitted(address indexed layer2);\n  event CommissionRateSet(address indexed layer2, uint256 previousRate, uint256 newRate);\n  event Paused(address account);\n  event Unpaused(address account);\n\n  // DEV ONLY\n  event CommitLog1(uint256 totalStakedAmount, uint256 totalSupplyOfWTON, uint256 prevTotalSupply, uint256 nextTotalSupply);\n\n  // DEV ONLY\n  event UnstakeLog(uint coinageBurnAmount, uint totBurnAmount);\n\n  event UpdatedSeigniorage(address indexed layer2, uint256 blockNumber, uint256 prevTotal, uint256 nextTotal, uint256 oldTotFactor, uint256 oldCoinageFactor, uint256 nextTotFactor, uint256 nextCoinageFactor);\n\n  //////////////////////////////\n  // Constuctor\n  //////////////////////////////\n\n  function initialize (\n    address ton_,\n    address wton_,\n    address registry_,\n    address depositManager_,\n    uint256 seigPerBlock_,\n    address factory_,\n    uint256 lastSeigBlock_\n  ) external {\n    require(_ton == address(0) && _lastSeigBlock == 0, \"already initialized\");\n\n    _ton = ton_;\n    _wton = wton_;\n    _registry = registry_;\n    _depositManager = depositManager_;\n    _seigPerBlock = seigPerBlock_;\n\n    factory = factory_;\n    address c = CoinageFactoryI(factory).deploy();\n    require(c != address(0), \"zero tot\");\n    _tot = AutoRefactorCoinageI(c);\n\n    _lastSeigBlock = lastSeigBlock_;\n  }\n\n  //////////////////////////////\n  // Pausable\n  //////////////////////////////\n\n  function pause() public onlyPauser whenNotPaused {\n    _pausedBlock = block.number;\n    paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /**\n   * @dev Called by a pauser to unpause, returns to normal state.\n   */\n  function unpause() public onlyPauser whenPaused {\n    _unpausedBlock = block.number;\n    paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n\n  //////////////////////////////\n  // onlyOwner\n  //////////////////////////////\n\n  function setData(\n      address powerton_,\n      address daoAddress,\n      uint256 powerTONSeigRate_,\n      uint256 daoSeigRate_,\n      uint256 relativeSeigRate_,\n      uint256 adjustDelay_,\n      uint256 minimumAmount_\n  ) external onlyOwner {\n    require(\n      powerTONSeigRate + daoSeigRate + relativeSeigRate <= RAY, \"exceeded seigniorage rate\"\n    );\n    _powerton = powerton_;\n    dao = daoAddress;\n    powerTONSeigRate = powerTONSeigRate_;\n    daoSeigRate = daoSeigRate_;\n    relativeSeigRate = relativeSeigRate_;\n    adjustCommissionDelay = adjustDelay_;\n    minimumAmount = minimumAmount_;\n  }\n\n  function setPowerTON(address powerton_) external onlyOwner {\n    _powerton = powerton_;\n  }\n\n  function setDao(address daoAddress) external onlyOwner {\n    dao = daoAddress;\n  }\n\n  function setPowerTONSeigRate(uint256 powerTONSeigRate_) external onlyOwner {\n    require(powerTONSeigRate_ > 0 && powerTONSeigRate_ < RAY, \"exceeded seigniorage rate\");\n    powerTONSeigRate = powerTONSeigRate_;\n  }\n\n  function setDaoSeigRate(uint256 daoSeigRate_) external onlyOwner {\n    require(daoSeigRate_ > 0 && daoSeigRate_ < RAY, \"exceeded seigniorage rate\");\n    daoSeigRate = daoSeigRate_;\n  }\n\n  function setPseigRate(uint256 pseigRate_) external onlyOwner {\n    require(pseigRate_ > 0 && pseigRate_ < RAY, \"exceeded seigniorage rate\");\n    relativeSeigRate = pseigRate_;\n  }\n\n  function setCoinageFactory(address factory_) external onlyOwner {\n    factory = factory_;\n  }\n\n  function transferCoinageOwnership(address newSeigManager, address[] calldata coinages_) external onlyOwner {\n    for (uint256 i = 0; i < coinages_.length; i++) {\n      AutoRefactorCoinageI c = AutoRefactorCoinageI(coinages_[i]);\n      c.addMinter(newSeigManager);\n      c.renounceMinter();\n      c.transferOwnership(newSeigManager);\n    }\n  }\n\n  function renounceWTONMinter() external onlyOwner {\n    IWTON(_wton).renounceMinter();\n  }\n\n  function setAdjustDelay(uint256 adjustDelay_) external onlyOwner {\n    adjustCommissionDelay = adjustDelay_;\n  }\n\n  function setMinimumAmount(uint256 minimumAmount_) external onlyOwner {\n    minimumAmount = minimumAmount_;\n  }\n\n\n  //////////////////////////////\n  // onlyRegistry\n  //////////////////////////////\n\n  /**\n   * @dev deploy coinage token for the layer2.\n   */\n  function deployCoinage(address layer2) external onlyRegistry returns (bool) {\n    // create new coinage token for the layer2 contract\n    if (address(_coinages[layer2]) == address(0)) {\n      address c = CoinageFactoryI(factory).deploy();\n      _lastCommitBlock[layer2] = block.number;\n      // addChallenger(layer2);\n      _coinages[layer2] = AutoRefactorCoinageI(c);\n      emit CoinageCreated(layer2, c);\n    }\n\n    return true;\n  }\n\n  function setCommissionRate(\n    address layer2,\n    uint256 commissionRate,\n    bool isCommissionRateNegative_\n  )\n    external\n    onlyRegistryOrOperator(layer2)\n    returns (bool)\n  {\n    // check commission range\n    require(\n      (commissionRate == 0) ||\n      (MIN_VALID_COMMISSION <= commissionRate && commissionRate <= MAX_VALID_COMMISSION),\n      \"SeigManager: commission rate must be 0 or between 1 RAY and 0.01 RAY\"\n    );\n\n    uint256 previous = _commissionRates[layer2];\n    if (adjustCommissionDelay == 0) {\n      _commissionRates[layer2] = commissionRate;\n      _isCommissionRateNegative[layer2] = isCommissionRateNegative_;\n    } else {\n      delayedCommissionBlock[layer2] = block.number + adjustCommissionDelay;\n      delayedCommissionRate[layer2] = commissionRate;\n      delayedCommissionRateNegative[layer2] = isCommissionRateNegative_;\n    }\n\n    emit CommissionRateSet(layer2, previous, commissionRate);\n\n    return true;\n  }\n\n  // No implementation in registry.\n  // function addChallenger(address account) public onlyRegistry {\n  //   grantRole(CHALLENGER_ROLE, account);\n  // }\n\n  // No implementation in layer2 (candidate).\n  function slash(address layer2, address challenger) external onlyChallenger checkCoinage(layer2) returns (bool) {\n    Layer2I(layer2).changeOperator(challenger);\n\n    return true;\n  }\n\n  //////////////////////////////\n  // onlyDepositManager\n  //////////////////////////////\n\n  /**\n   * @dev Callback for a new deposit\n   */\n  function onDeposit(address layer2, address account, uint256 amount)\n    external\n    onlyDepositManager\n    checkCoinage(layer2)\n    returns (bool)\n  {\n    if (_isOperator(layer2, account)) {\n      uint256 newAmount = _coinages[layer2].balanceOf(account) + amount;\n      require(newAmount >= minimumAmount, \"minimum amount is required\");\n    }\n    _tot.mint(layer2, amount);\n    _coinages[layer2].mint(account, amount);\n    if (address(_powerton) != address(0)) {\n      IPowerTON(_powerton).onDeposit(layer2, account, amount);\n    }\n    return true;\n  }\n\n  function onWithdraw(address layer2, address account, uint256 amount)\n    external\n    onlyDepositManager\n    checkCoinage(layer2)\n    returns (bool)\n  {\n    require(_coinages[layer2].balanceOf(account) >= amount, \"SeigManager: insufficiant balance to unstake\");\n\n    if (_isOperator(layer2, account)) {\n      uint256 newAmount = _coinages[layer2].balanceOf(account) - amount;\n      require(newAmount >= minimumAmount, \"minimum amount is required\");\n    }\n\n    // burn {v + ⍺} {tot} tokens to the layer2 contract,\n    uint256 totAmount = _additionalTotBurnAmount(layer2, account, amount);\n    _tot.burnFrom(layer2, amount+totAmount);\n\n    // burn {v} {coinages[layer2]} tokens to the account\n    _coinages[layer2].burnFrom(account, amount);\n\n    if (address(_powerton) != address(0)) {\n      IPowerTON(_powerton).onWithdraw(layer2, account, amount);\n    }\n\n    emit UnstakeLog(amount, totAmount);\n\n    return true;\n  }\n\n\n  //////////////////////////////\n  // checkCoinage\n  //////////////////////////////\n\n  /**\n   * @dev Callback for a new commit\n   */\n  function updateSeigniorage()\n    external\n    checkCoinage(msg.sender)\n    returns (bool)\n  {\n    // short circuit if paused\n    if (paused) {\n      return true;\n    }\n    require(block.number > _lastSeigBlock, \"last seig block is not past\");\n\n    uint256 operatorAmount = getOperatorAmount(msg.sender);\n    require(operatorAmount >= minimumAmount, \"minimumAmount is insufficient\");\n\n    AutoRefactorCoinageI coinage = _coinages[msg.sender];\n\n    uint256 oldCoinageFactor = coinage.factor();\n    uint256 oldTotFactor = _tot.factor();\n\n    _increaseTot();\n\n    _lastCommitBlock[msg.sender] = block.number;\n\n    // 2. increase total supply of {coinages[layer2]}\n    // AutoRefactorCoinageI coinage = _coinages[msg.sender];\n\n    uint256 prevTotalSupply = coinage.totalSupply();\n    uint256 nextTotalSupply = _tot.balanceOf(msg.sender);\n\n    // short circuit if there is no seigs for the layer2\n    if (prevTotalSupply >= nextTotalSupply) {\n      emit Comitted(msg.sender);\n      return true;\n    }\n\n    uint256 seigs = nextTotalSupply - prevTotalSupply;\n    address operator = Layer2I(msg.sender).operator();\n    uint256 operatorSeigs;\n\n    // calculate commission amount\n    bool isCommissionRateNegative_ = _isCommissionRateNegative[msg.sender];\n\n    (nextTotalSupply, operatorSeigs) = _calcSeigsDistribution(\n      msg.sender,\n      coinage,\n      prevTotalSupply,\n      seigs,\n      isCommissionRateNegative_,\n      operator\n    );\n\n    // gives seigniorages to the layer2 as coinage\n    coinage.setFactor(\n      _calcNewFactor(\n        prevTotalSupply,\n        nextTotalSupply,\n        coinage.factor()\n      )\n    );\n\n    // give commission to operator or delegators\n    if (operatorSeigs != 0) {\n      if (isCommissionRateNegative_) {\n        // TODO: adjust arithmetic error\n        // burn by 𝜸\n        coinage.burnFrom(operator, operatorSeigs);\n      } else {\n        coinage.mint(operator, operatorSeigs);\n      }\n    }\n\n    uint256 newCoinageFactor = coinage.factor();\n    uint256 newTotFactor = _tot.factor();\n\n    IWTON(_wton).mint(address(_depositManager), seigs);\n\n    emit Comitted(msg.sender);\n    emit UpdatedSeigniorage(msg.sender, block.number, prevTotalSupply, nextTotalSupply, oldTotFactor, oldCoinageFactor, newTotFactor, newCoinageFactor);\n    return true;\n  }\n\n\n  //////////////////////////////\n  // External functions\n  //////////////////////////////\n\n  function getOperatorAmount(address layer2) public view returns (uint256) {\n    address operator = Layer2I(msg.sender).operator();\n    return _coinages[layer2].balanceOf(operator);\n  }\n\n  /**\n   * @dev Callback for a token transfer\n   */\n  function onTransfer(address sender, address recipient, uint256 amount) external returns (bool) {\n    require(msg.sender == address(_ton) || msg.sender == address(_wton),\n      \"SeigManager: only TON or WTON can call onTransfer\");\n\n    if (!paused) {\n      _increaseTot();\n    }\n\n    return true;\n  }\n\n\n  function additionalTotBurnAmount(address layer2, address account, uint256 amount)\n    external\n    view\n    returns (uint256 totAmount)\n  {\n    return _additionalTotBurnAmount(layer2, account, amount);\n  }\n\n\n  function uncomittedStakeOf(address layer2, address account) external view returns (uint256) {\n    AutoRefactorCoinageI coinage = AutoRefactorCoinageI(_coinages[layer2]);\n\n    uint256 prevFactor = coinage.factor();\n    uint256 prevTotalSupply = coinage.totalSupply();\n    uint256 nextTotalSupply = _tot.balanceOf(layer2);\n    uint256 newFactor = _calcNewFactor(prevTotalSupply, nextTotalSupply, prevFactor);\n\n    uint256 uncomittedBalance = rmul(\n      rdiv(coinage.balanceOf(account), prevFactor),\n      newFactor\n    );\n\n    return (uncomittedBalance - _coinages[layer2].balanceOf(account));\n  }\n\n  function stakeOf(address layer2, address account) external view returns (uint256) {\n    return _coinages[layer2].balanceOf(account);\n  }\n\n  //////////////////////////////\n  // Public functions\n  //////////////////////////////\n\n\n  //////////////////////////////\n  // Internal functions\n  //////////////////////////////\n\n  // return ⍺, where ⍺ = (tot.balanceOf(layer2) - coinages[layer2].totalSupply()) * (amount / coinages[layer2].totalSupply())\n  function _additionalTotBurnAmount(address layer2, address account, uint256 amount)\n    internal\n    view\n    returns (uint256 totAmount)\n  {\n    uint256 coinageTotalSupply = _coinages[layer2].totalSupply();\n    uint256 totBalalnce = _tot.balanceOf(layer2);\n\n    // NOTE: arithamtic operations (mul and div) make some errors, so we gonna adjust them under 1e-9 WTON.\n    //       note that coinageTotalSupply and totBalalnce are RAY values.\n    if (coinageTotalSupply > totBalalnce && coinageTotalSupply - totBalalnce < WAD_) {\n      return 0;\n    }\n\n    return rdiv(\n      rmul(\n        totBalalnce - coinageTotalSupply,\n        amount\n      ),\n      coinageTotalSupply\n    );\n  }\n\n\n  function _calcSeigsDistribution(\n    address layer2,\n    AutoRefactorCoinageI coinage,\n    uint256 prevTotalSupply,\n    uint256 seigs,\n    bool isCommissionRateNegative_,\n    address operator\n  ) internal returns (\n    uint256 nextTotalSupply,\n    uint256 operatorSeigs\n  ) {\n    if (block.number >= delayedCommissionBlock[layer2] && delayedCommissionBlock[layer2] != 0) {\n      _commissionRates[layer2] = delayedCommissionRate[layer2];\n      _isCommissionRateNegative[layer2] = delayedCommissionRateNegative[layer2];\n      delayedCommissionBlock[layer2] = 0;\n    }\n\n    uint256 commissionRate = _commissionRates[msg.sender];\n\n    nextTotalSupply = prevTotalSupply + seigs;\n\n    // short circuit if there is no commission rate\n    if (commissionRate == 0) {\n      return (nextTotalSupply, operatorSeigs);\n    }\n\n    // if commission rate is possitive\n    if (!isCommissionRateNegative_) {\n      operatorSeigs = rmul(seigs, commissionRate); // additional seig for operator\n      nextTotalSupply = nextTotalSupply - operatorSeigs;\n      return (nextTotalSupply, operatorSeigs);\n    }\n\n    // short circuit if there is no previous total deposit (meanning, there is no deposit)\n    if (prevTotalSupply == 0) {\n      return (nextTotalSupply, operatorSeigs);\n    }\n\n    // See negative commission distribution formular here: TBD\n    uint256 operatorBalance = coinage.balanceOf(operator);\n\n    // short circuit if there is no operator deposit\n    if (operatorBalance == 0) {\n      return (nextTotalSupply, operatorSeigs);\n    }\n\n    uint256 operatorRate = rdiv(operatorBalance, prevTotalSupply);\n\n    // ɑ: insufficient seig for operator\n    operatorSeigs = rmul(\n      rmul(seigs, operatorRate), // seigs for operator\n      commissionRate\n    );\n\n    // β:\n    uint256 delegatorSeigs = operatorRate == RAY\n      ? operatorSeigs\n      : rdiv(operatorSeigs, RAY - operatorRate);\n\n    // 𝜸:\n    operatorSeigs = operatorRate == RAY\n      ? operatorSeigs\n      : operatorSeigs + rmul(delegatorSeigs, operatorRate);\n\n    nextTotalSupply = nextTotalSupply + delegatorSeigs;\n\n    return (nextTotalSupply, operatorSeigs);\n  }\n\n  function _calcNewFactor(uint256 source, uint256 target, uint256 oldFactor) internal pure returns (uint256) {\n    return rdiv(rmul(target, oldFactor), source);\n  }\n\n\n  function _calcNumSeigBlocks() internal view returns (uint256) {\n    require(!paused);\n\n    uint256 span = block.number - _lastSeigBlock;\n    if (_unpausedBlock < _lastSeigBlock) {\n      return span;\n    }\n\n    return span - (_unpausedBlock - _pausedBlock);\n  }\n\n  function _isOperator(address layer2, address operator) internal view returns (bool) {\n    return operator == Layer2I(layer2).operator();\n  }\n\n\n  function _increaseTot() internal returns (bool) {\n    // short circuit if already seigniorage is given.\n    if (block.number <= _lastSeigBlock) {\n      return false;\n    }\n\n    if (AutoRefactorCoinageI(_tot).totalSupply() == 0) {\n      _lastSeigBlock = block.number;\n      return false;\n    }\n\n    uint256 prevTotalSupply;\n    uint256 nextTotalSupply;\n\n    // 1. increase total supply of {tot} by maximum seigniorages * staked rate\n    //    staked rate = total staked amount / total supply of (W)TON\n\n    prevTotalSupply = _tot.totalSupply();\n\n    // maximum seigniorages\n    uint256 maxSeig = _calcNumSeigBlocks() * _seigPerBlock;\n\n    // total supply of (W)TON\n    uint256 tos = ((ITON(_ton).totalSupply() - ITON(_ton).balanceOf(_wton)) * (10 ** 9)) + (_tot.totalSupply());  // consider additional TOT balance as total supply\n\n    // maximum seigniorages * staked rate\n    uint256 stakedSeig = rdiv(\n      rmul(\n        maxSeig,\n        // total staked amount\n        _tot.totalSupply()\n      ),\n      tos\n    );\n\n    // pseig\n    uint256 totalPseig = rmul(maxSeig - stakedSeig, relativeSeigRate);\n\n    nextTotalSupply = prevTotalSupply + stakedSeig + totalPseig;\n    _lastSeigBlock = block.number;\n\n    _tot.setFactor(_calcNewFactor(prevTotalSupply, nextTotalSupply, _tot.factor()));\n\n    // TODO: reduce computation\n    // DEV ONLY\n    emit CommitLog1(\n      _tot.totalSupply(),\n      tos,\n      prevTotalSupply,\n      nextTotalSupply\n    );\n\n    uint256 unstakedSeig = maxSeig - stakedSeig;\n    uint256 powertonSeig;\n    uint256 daoSeig;\n    uint256 relativeSeig;\n\n    if (address(_powerton) != address(0)) {\n      powertonSeig = rmul(unstakedSeig, powerTONSeigRate);\n      IWTON(_wton).mint(address(_powerton), powertonSeig);\n    }\n\n    if (dao != address(0)) {\n      daoSeig = rmul(unstakedSeig, daoSeigRate);\n      IWTON(_wton).mint(address(dao), daoSeig);\n    }\n\n    if (relativeSeigRate != 0) {\n      relativeSeig = totalPseig;\n      accRelativeSeig = accRelativeSeig + relativeSeig;\n    }\n\n    emit SeigGiven(msg.sender, maxSeig, stakedSeig, unstakedSeig, powertonSeig, relativeSeig);\n\n    return true;\n  }\n\n\n  //////////////////////////////\n  // Storage getters\n  //////////////////////////////\n\n  // solium-disable\n  function registry() external view returns (address) { return address(_registry); }\n  function depositManager() external view returns (address) { return address(_depositManager); }\n  function ton() external view returns (address) { return address(_ton); }\n  function wton() external view returns (address) { return address(_wton); }\n  function powerton() external view returns (address) { return address(_powerton); }\n  function tot() external view returns (address) { return address(_tot); }\n  function coinages(address layer2) external view returns (address) { return address(_coinages[layer2]); }\n  function commissionRates(address layer2) external view returns (uint256) { return _commissionRates[layer2]; }\n  function isCommissionRateNegative(address layer2) external view returns (bool) { return _isCommissionRateNegative[layer2]; }\n\n  function lastCommitBlock(address layer2) external view returns (uint256) { return _lastCommitBlock[layer2]; }\n  function seigPerBlock() external view returns (uint256) { return _seigPerBlock; }\n  function lastSeigBlock() external view returns (uint256) { return _lastSeigBlock; }\n  function pausedBlock() external view returns (uint256) { return _pausedBlock; }\n  function unpausedBlock() external view returns (uint256) { return _unpausedBlock; }\n\n  function DEFAULT_FACTOR() external pure returns (uint256) { return _DEFAULT_FACTOR; }\n  // solium-enable\n\n\n  //====\n  function renounceMinter(address target) public onlyOwner {\n    MinterRoleRenounceTarget(target).renounceMinter();\n  }\n\n  function renouncePauser(address target) public onlyOwner {\n    PauserRoleRenounceTarget(target).renouncePauser();\n  }\n\n  function renounceOwnership(address target) public onlyOwner {\n    OwnableTarget(target).renounceOwnership();\n  }\n\n  function transferOwnership(address target, address newOwner) public onlyOwner {\n    OwnableTarget(target).transferOwnership(newOwner);\n  }\n\n  //=====\n\n}\n"
    },
    "contracts/stake/managers/SeigManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/ProxySeigManager.sol\";\nimport \"./SeigManagerStorage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract SeigManagerProxy is ProxySeigManager, SeigManagerStorage {\n\n}\n"
    },
    "contracts/stake/managers/SeigManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport { AutoRefactorCoinageI } from \"../interfaces/AutoRefactorCoinageI.sol\";\n\n/// @title\n/// @notice\ncontract SeigManagerStorage   {\n\n    //////////////////////////////\n    // Constants\n    //////////////////////////////\n\n    uint256 constant public RAY = 10 ** 27; // 1 RAY\n    uint256 constant internal _DEFAULT_FACTOR = RAY;\n\n    uint256 constant public MAX_VALID_COMMISSION = RAY; // 1 RAY\n    uint256 constant public MIN_VALID_COMMISSION = 10 ** 25; // 0.01 RAY\n\n    //////////////////////////////\n    // Common contracts\n    //////////////////////////////\n\n    address internal _registry;\n    address internal _depositManager;\n    address internal _powerton;\n    address public dao;\n\n    //////////////////////////////\n    // Token-related\n    //////////////////////////////\n\n    // TON token contract\n    address internal _ton;\n\n    // WTON token contract\n    address internal _wton; // TODO: use mintable erc20!\n\n    // contract factory\n    address public factory;\n\n    // track total deposits of each layer2.\n    AutoRefactorCoinageI internal _tot;\n\n    // coinage token for each layer2.\n    mapping (address => AutoRefactorCoinageI) internal _coinages;\n\n    // last commit block number for each layer2.\n    mapping (address => uint256) internal _lastCommitBlock;\n\n    // total seigniorage per block\n    uint256 internal _seigPerBlock;\n\n    // the block number when seigniorages are given\n    uint256 internal _lastSeigBlock;\n\n    // block number when paused or unpaused\n    uint256 internal _pausedBlock;\n    uint256 internal _unpausedBlock;\n\n    // commission rates in RAY\n    mapping (address => uint256) internal _commissionRates;\n\n    // whether commission is negative or not (default=possitive)\n    mapping (address => bool) internal _isCommissionRateNegative;\n\n    // setting commissionrate delay\n    uint256 public adjustCommissionDelay;\n    mapping (address => uint256) public delayedCommissionBlock;\n    mapping (address => uint256) public delayedCommissionRate;\n    mapping (address => bool) public delayedCommissionRateNegative;\n\n    // minimum deposit amount\n    uint256 public minimumAmount;\n\n    uint256 public powerTONSeigRate;\n    uint256 public daoSeigRate;\n    uint256 public relativeSeigRate;\n\n    uint256 public accRelativeSeig;\n\n    bool public paused;\n}\n"
    },
    "contracts/stake/powerton/PowerTONHammerDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {iPowerTON} from \"../interfaces/iPowerTON.sol\";\nimport \"../interfaces/IPowerTONSwapperEvent.sol\";\n\nimport \"../interfaces/IIERC20.sol\";\nimport \"../interfaces/IAutoCoinageSnapshot.sol\";\n\nimport \"../../common/AccessiblePowerTon.sol\";\nimport \"./PowerTONSwapperStorage.sol\";\n\nimport {PowerTONHammerDAOStorage} from \"./PowerTONHammerDAOStorage.sol\";\nimport {ILockTOSDividend} from \"../interfaces/ILockTOSDividend.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract PowerTONHammerDAO is\n    PowerTONSwapperStorage,\n    AccessiblePowerTon,\n    iPowerTON,\n    IPowerTONSwapperEvent,\n    PowerTONHammerDAOStorage\n{\n    modifier onlySeigManagerOrOwner() {\n        require(\n            isAdmin(msg.sender) || msg.sender == seigManager,\n            \"PowerTONHammerDAO: sender is not seigManager or not admin\"\n        );\n        _;\n    }\n\n    event OnChangeAmountInRecoder(\n        address indexed account,\n        uint256 amountToMint,\n        uint256 amountToBurn\n    );\n\n    constructor() {}\n\n    function setInfo(\n        address _wton,\n        address _autocoinageSnapshot,\n        address _seigManager,\n        address _dividiedPool\n    ) external onlyOwner {\n        wton = _wton;\n        autocoinageSnapshot = _autocoinageSnapshot;\n        seigManager = _seigManager;\n        dividiedPool = ILockTOSDividend(_dividiedPool);\n    }\n\n    function setAutocoinageSnapshot(address _autocoinageSnapshot)\n        external\n        onlyOwner\n    {\n        autocoinageSnapshot = _autocoinageSnapshot;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function approveToUniswap() external {}\n\n    /// @notice PowerTON으로 쌓인 WTON 전체를 LockTOSDividendProxy 컨트랙트에 위임\n    function approveToDividendPool() private {\n        IERC20(wton).approve(address(dividiedPool), type(uint256).max);\n    }\n\n    /// @notice LockTOSDividendProxy 컨트랙트를 사용해서 WTON을 sTOS 홀더에게 에어드랍\n    function distribute() external {\n        uint256 wtonBalance = getWTONBalance();\n        require(wtonBalance > 0, \"balance of WTON is 0\");\n\n        // WTON 잔고보다 allowance가 낮으면 최대 값으로 위임 재설정\n        if (\n            wtonBalance >\n            IERC20(wton).allowance(address(this), address(dividiedPool))\n        ) {\n            approveToDividendPool();\n        }\n\n        dividiedPool.distribute(wton, wtonBalance);\n        emit Distributed(wton, wtonBalance);\n    }\n\n    function getWTONBalance() public view returns (uint256) {\n        return IERC20(wton).balanceOf(address(this));\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function currentRound() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function roundDuration() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function totalDeposits() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function winnerOf(uint256 round) external pure override returns (address) {\n        return address(0);\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function powerOf(address account) external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function init() external override {}\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function start() external override {}\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function endRound() external override {}\n\n    function onDeposit(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external override onlySeigManagerOrOwner {\n        IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnDeposit(layer2, account, amount);\n    }\n\n    function onWithdraw(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external override onlySeigManagerOrOwner {\n        IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnWithdraw(layer2, account, amount);\n    }\n}"
    },
    "contracts/stake/powerton/PowerTONHammerDAOStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ILockTOSDividend } from \"../interfaces/ILockTOSDividend.sol\";\n\ncontract PowerTONHammerDAOStorage {\n    ILockTOSDividend public dividiedPool;\n}"
    },
    "contracts/stake/powerton/PowerTONSwapperStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ITOS } from \"../interfaces/ITOS.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\ncontract PowerTONSwapperStorage {\n\n    bool public pauseProxy;\n\n    address public wton;\n    ITOS public tos;\n    ISwapRouter public uniswapRouter;\n    address public autocoinageSnapshot;\n    address public layer2Registry;\n    address public seigManager;\n\n    bool public migratedL2;\n}\n"
    },
    "contracts/stake/powerton/PowerTONUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IPowerTONSwapperEvent.sol\";\nimport \"../interfaces/IAutoCoinageSnapshot.sol\";\nimport {ILockTOSDividend} from \"../interfaces/ILockTOSDividend.sol\";\n\n\nimport \"../../common/AccessiblePowerTon.sol\";\nimport \"./PowerTONSwapperStorage.sol\";\nimport {PowerTONHammerDAOStorage} from \"./PowerTONHammerDAOStorage.sol\";\n\n\ncontract PowerTONUpgrade is\n    PowerTONSwapperStorage,\n    AccessiblePowerTon,\n    IPowerTONSwapperEvent,\n    PowerTONHammerDAOStorage\n{\n\n    function setAutocoinageSnapshot(address _autocoinageSnapshot)\n        external\n        onlyOwner\n    {\n        autocoinageSnapshot = _autocoinageSnapshot;\n    }\n\n    function setSeigManager(address _seigManager)\n        external\n        onlyOwner\n    {\n        seigManager = _seigManager;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function approveToUniswap() external {}\n\n    /// @notice PowerTON으로 쌓인 WTON 전체를 LockTOSDividendProxy 컨트랙트에 위임\n    function approveToDividendPool() private {\n        IERC20(wton).approve(address(dividiedPool), type(uint256).max);\n    }\n\n    /// @notice LockTOSDividendProxy 컨트랙트를 사용해서 WTON을 sTOS 홀더에게 에어드랍\n    function distribute() external {\n        uint256 wtonBalance = getWTONBalance();\n        require(wtonBalance > 0, \"balance of WTON is 0\");\n\n        // WTON 잔고보다 allowance가 낮으면 최대 값으로 위임 재설정\n        if (\n            wtonBalance >\n            IERC20(wton).allowance(address(this), address(dividiedPool))\n        ) {\n            approveToDividendPool();\n        }\n\n        dividiedPool.distribute(wton, wtonBalance);\n        emit Distributed(wton, wtonBalance);\n    }\n\n    function getWTONBalance() public view returns (uint256) {\n        return IERC20(wton).balanceOf(address(this));\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function currentRound() external pure returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function roundDuration() external pure returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function totalDeposits() external pure returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function winnerOf(uint256 round) external pure returns (address) {\n        return address(0);\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function powerOf(address account) external pure returns (uint256) {\n        return 0;\n    }\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function init() external {}\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function start() external {}\n\n    /// @dev 업그레이드 이후 사용되지 않는 함수\n    function endRound() external {}\n\n    function onDeposit(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external  {\n        // IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnDeposit(layer2, account, amount);\n    }\n\n    function onWithdraw(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external  {\n        // IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnWithdraw(layer2, account, amount);\n    }\n}"
    },
    "contracts/stake/powerton/PowerTonV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\nimport { PowerTonV2Storage } from \"./PowerTonV2Storage.sol\";\n\ninterface ILockTOSDividend {\n    function distribute(address _token, uint256 _amount) external;\n}\n\n\ncontract PowerTonV2 is  ProxyStorage, AccessibleCommon, PowerTonV2Storage {\n\n    modifier onlySeigManagerOrOwner() {\n        require(\n            isAdmin(msg.sender) || msg.sender == seigManager,\n            \"sender is not seigManager or not admin\"\n        );\n        _;\n    }\n\n    event Distributed(address token, uint256 amount);\n\n    function setInfo(\n        address _wton,\n        address _seigManager,\n        address _seigManagerV2,\n        address _dividiedPool,\n        uint256 _ratioForStos,\n        uint256 _ratioForStakingV2\n    ) external onlyOwner {\n        require(_ratioForStos + _ratioForStakingV2 == 1e18, 'wrong ratio');\n\n        wton = _wton;\n        seigManager = _seigManager;\n        seigManagerV2 = _seigManagerV2;\n        dividiedPoolForStos = _dividiedPool;\n        ratioForStos = _ratioForStos;\n        ratioForStakingV2 = _ratioForStakingV2;\n    }\n\n    function approveToDividendPool() private {\n        IERC20(wton).approve(dividiedPoolForStos, type(uint256).max);\n    }\n\n    /// @notice LockTOSDividendProxy 컨트랙트를 사용해서 WTON을 sTOS 홀더에게 에어드랍\n    function distribute() external {\n        uint256 wtonBalance = getWTONBalance();\n        require(wtonBalance > 0, \"balance of WTON is 0\");\n\n        // WTON 잔고보다 allowance가 낮으면 최대 값으로 위임 재설정\n        if (\n            wtonBalance >\n            IERC20(wton).allowance(address(this), address(dividiedPoolForStos))\n        ) {\n            approveToDividendPool();\n        }\n\n        ILockTOSDividend(dividiedPoolForStos).distribute(wton, wtonBalance);\n        emit Distributed(wton, wtonBalance);\n    }\n\n    function getWTONBalance() public view returns (uint256) {\n        return IERC20(wton).balanceOf(address(this));\n    }\n\n    function onDeposit(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external onlySeigManagerOrOwner {\n        //IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnDeposit(layer2, account, amount);\n    }\n\n    function onWithdraw(\n        address layer2,\n        address account,\n        uint256 amount\n    ) external onlySeigManagerOrOwner {\n        // IAutoCoinageSnapshot(autocoinageSnapshot).addSync(layer2, account);\n        //emit OnWithdraw(layer2, account, amount);\n    }\n\n}\n"
    },
    "contracts/stake/powerton/PowerTonV2Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/Proxy.sol\";\nimport \"./PowerTonV2Storage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract PowerTonV2Proxy is Proxy, PowerTonV2Storage {\n\n}\n"
    },
    "contracts/stake/powerton/PowerTonV2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract PowerTonV2Storage   {\n\n    address public wton;\n    address public seigManager;\n    address public seigManagerV2;\n    address public dividiedPoolForStos;\n\n    uint256 ratioForStos;       // 1e18\n    uint256 ratioForStakingV2;  // 1e18\n\n}\n"
    },
    "contracts/stake/tokens/AutoRefactorCoinage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { AutoRefactorCoinageI } from \"../interfaces/AutoRefactorCoinageI.sol\";\nimport { DSMath } from \"../../libraries/DSMath.sol\";\n\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AuthControlCoinage } from \"../../common/AuthControlCoinage.sol\";\nimport { AutoRefactorCoinageStorage } from \"./AutoRefactorCoinageStorage.sol\";\n\n\n/**\n * @dev Implementation of coin age token based on ERC20 of openzeppelin/-solidity\n *\n * AutoRefactorCoinage stores `_totalSupply` and `_balances` as RAY BASED value,\n * `_allowances` as RAY FACTORED value.\n *\n * This takes public function (including _approve) parameters as RAY FACTORED value\n * and internal function (including approve) parameters as RAY BASED value, and emits event in RAY FACTORED value.\n *\n * `RAY BASED` = `RAY FACTORED`  / factor\n *\n *  factor increases exponentially for each block mined.\n */\ncontract AutoRefactorCoinage is ProxyStorage, AuthControlCoinage, AutoRefactorCoinageStorage, DSMath {\n\n  event FactorSet(uint256 previous, uint256 current, uint256 shiftCount);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event ChangedBalance(address indexed account, uint256 balance, uint256 refactoredCount);\n\n  function initialize (\n    string memory name_,\n    string memory symbol_,\n    uint256 factor_\n  ) external {\n\n    require(_factor == 0, \"already initialized\");\n\n    name = name_;\n    symbol = symbol_;\n    _factor = factor_;\n    //_factorIncrement = factorIncrement;\n    //_lastBlock = block.number;\n    //_transfersEnabled = transfersEnabled;\n  }\n\n\n  /**\n   *  onlyOwner\n   **/\n\n  function setFactor(uint256 factor_) external onlyOwner returns (bool) {\n    uint256 previous = _factor;\n\n    uint256 count = 0;\n    uint256 f = factor_;\n    for (; f >= REFACTOR_BOUNDARY; f = f / REFACTOR_DIVIDER) {\n      count = count++;\n    }\n\n    refactorCount = count;\n    _factor = f;\n    emit FactorSet(previous, f, count);\n    return true;\n  }\n\n  /**\n   *  onlyMinter\n   **/\n\n  function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n  }\n\n  function burnFrom(address account, uint256 amount) public onlyMinter {\n      _burnFrom(account, amount);\n  }\n\n  // -------- external\n\n  function burn(uint256 amount) external {\n      _burn(msg.sender, amount);\n  }\n\n  function decimals() external view virtual returns (uint8) {\n      return 27;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount) + _totalSupply.remain;\n  }\n\n  // -------- public\n\n  function factor() public view returns (uint256) {\n    uint256 result = _factor;\n    for (uint256 i = 0; i < refactorCount; i++) {\n      result = result * REFACTOR_DIVIDER;\n    }\n    return result;\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    Balance storage b = balances[account];\n\n    return _applyFactor(b.balance, b.refactoredCount) + b.remain;\n  }\n\n  // -------- internal\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n    * the total supply.\n    *\n    * Emits a {Transfer} event with `from` set to the zero address.\n    *\n    * Requirements\n    *\n    * - `to` cannot be the zero address.\n    */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"AutoRefactorCoinage: mint to the zero address\");\n    Balance storage b = balances[account];\n\n    uint256 currentBalance = balanceOf(account);\n    uint256 newBalance = currentBalance + amount;\n\n    uint256 rbAmount = _toRAYBased(newBalance);\n    b.balance = rbAmount;\n    b.refactoredCount = refactorCount;\n\n    addTotalSupply(amount);\n\n    emit ChangedBalance(account, rbAmount, refactorCount);\n\n    emit Transfer(address(0), account, _toRAYFactored(rbAmount));\n  }\n\n    /**\n    * @dev Destroys `amount` tokens from `account`, reducing the\n    * total supply.\n    *\n    * Emits a {Transfer} event with `to` set to the zero address.\n    *\n    * Requirements\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    */\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"AutoRefactorCoinage: burn from the zero address\");\n    Balance storage b = balances[account];\n\n    uint256 currentBalance = balanceOf(account);\n    uint256 newBalance = currentBalance - amount;\n\n    uint256 rbAmount = _toRAYBased(newBalance);\n    b.balance = rbAmount;\n    b.refactoredCount = refactorCount;\n\n    subTotalSupply(amount);\n\n    emit ChangedBalance(account, rbAmount, refactorCount);\n\n    emit Transfer(account, address(0), _toRAYFactored(rbAmount));\n  }\n\n  function _burnFrom(address account, uint256 amount) internal {\n    _burn(account, amount);\n  }\n\n  /**\n   * @param v the value to be factored\n   */\n  function _applyFactor(uint256 v, uint256 refactoredCount) internal view returns (uint256) {\n    if (v == 0) {\n      return 0;\n    }\n\n    v = rmul2(v, _factor);\n\n    for (uint256 i = refactoredCount; i < refactorCount; i++) {\n      v = v * REFACTOR_DIVIDER;\n    }\n\n    return v;\n  }\n\n  /**\n   * @dev Calculate RAY BASED from RAY FACTORED\n   */\n  function _toRAYBased(uint256 rf) internal view returns (uint256 rb) {\n    return rdiv2(rf, _factor);\n  }\n\n  /**\n   * @dev Calculate RAY FACTORED from RAY BASED\n   */\n  function _toRAYFactored(uint256 rb) internal view returns (uint256 rf) {\n    return rmul2(rb, _factor);\n  }\n\n  function addTotalSupply(uint256 amount) internal {\n    uint256 currentSupply = _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount);\n    uint256 newSupply = currentSupply + amount;\n\n    uint256 rbAmount = _toRAYBased(newSupply);\n    _totalSupply.balance = rbAmount;\n    _totalSupply.refactoredCount = refactorCount;\n\n    emit ChangedBalance(address(0), rbAmount, refactorCount);\n  }\n\n  function subTotalSupply(uint256 amount) internal {\n    uint256 currentSupply = _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount);\n    uint256 newSupply = currentSupply - amount;\n\n    uint256 rbAmount = _toRAYBased(newSupply);\n    _totalSupply.balance = rbAmount;\n    _totalSupply.refactoredCount = refactorCount;\n\n    emit ChangedBalance(address(0), rbAmount, refactorCount);\n  }\n\n  // unsupported functions\n\n  // function transfer(address recipient, uint256 amount) public returns (bool) {\n  //   revert();\n  // }\n\n  // function allowance(address owner, address spender) public view returns (uint256) {\n  //   return 0;\n  // }\n\n  // function approve(address spender, uint256 amount) public returns (bool) {\n  //   revert();\n  // }\n\n  // function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n  //   revert();\n  // }\n}\n"
    },
    "contracts/stake/tokens/AutoRefactorCoinageProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/ProxyCoinage.sol\";\nimport \"./AutoRefactorCoinageStorage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract AutoRefactorCoinageProxy is ProxyCoinage, AutoRefactorCoinageStorage {\n\n}\n"
    },
    "contracts/stake/tokens/AutoRefactorCoinageStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract AutoRefactorCoinageStorage   {\n\n    struct Balance {\n        uint256 balance;\n        uint256 refactoredCount;\n        uint256 remain;\n    }\n\n    uint256 public REFACTOR_BOUNDARY = 10 ** 28;\n    uint256 public REFACTOR_DIVIDER = 2;\n\n    uint256 public refactorCount;\n\n    mapping (address => Balance) public balances;\n\n    Balance public _totalSupply;\n\n    uint256 public _factor;\n\n    bool internal _transfersEnabled;\n\n    //=== ERC20\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => uint256)) public _allowances;\n\n}\n"
    },
    "contracts/stake/tokens/RefactorCoinageSnapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { AutoRefactorCoinageI } from \"../interfaces/AutoRefactorCoinageI.sol\";\nimport { DSMath } from \"../../libraries/DSMath.sol\";\nimport \"../../libraries/SArrays.sol\";\n\nimport \"../../proxy/ProxyStorage.sol\";\nimport { AuthControlCoinage } from \"../../common/AuthControlCoinage.sol\";\nimport { RefactorCoinageSnapshotStorage } from \"./RefactorCoinageSnapshotStorage.sol\";\n\n\n/**\n * @dev Implementation of coin age token based on ERC20 of openzeppelin/-solidity\n *\n * AutoRefactorCoinage stores `_totalSupply` and `_balances` as RAY BASED value,\n * `_allowances` as RAY FACTORED value.\n *\n * This takes public function (including _approve) parameters as RAY FACTORED value\n * and internal function (including approve) parameters as RAY BASED value, and emits event in RAY FACTORED value.\n *\n * `RAY BASED` = `RAY FACTORED`  / factor\n *\n *  factor increases exponentially for each block mined.\n */\ncontract RefactorCoinageSnapshot is ProxyStorage, AuthControlCoinage, RefactorCoinageSnapshotStorage, DSMath {\n    using SArrays for uint256[];\n\n    event FactorSet(uint256 previous, uint256 current, uint256 shiftCount);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event ChangedBalance(address indexed account, Balance oldBalance, Balance newBalance, Balance oldTotalBalance, Balance newTotalBalance);\n    event ChangedFactor(Factor previous, Factor next);\n\n    function initialize (\n      string memory name_,\n      string memory symbol_,\n      uint256 factor_\n    ) external {\n\n      require(factorSnapshots[0].factor == 0, \"already initialized\");\n\n      name = name_;\n      symbol = symbol_;\n      factorSnapshots[0] = Factor(factor_, 0);\n\n    }\n\n\n    /**\n     *  onlyOwner\n     **/\n\n    function setFactor(uint256 factor_) external onlyOwner returns (bool) {\n      Factor memory previous = _valueAtFactorLast();\n      // uint256 previous = _factor;\n\n      uint256 count = 0;\n      uint256 f = factor_;\n      for (; f >= REFACTOR_BOUNDARY; f = f / REFACTOR_DIVIDER) {\n        count = count++;\n      }\n\n      Factor memory nextFactor = Factor(f, count);\n      _updateFactor(nextFactor);\n\n      emit ChangedFactor(previous, nextFactor);\n      return true;\n    }\n\n    /**\n     *  onlyMinter\n     **/\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n          _mint(account, amount);\n          return true;\n    }\n\n    function burnFrom(address account, uint256 amount) public onlyMinter {\n        _burn(account, amount);\n    }\n\n    // -------- external\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function decimals() external view virtual returns (uint8) {\n        return 27;\n    }\n\n    // -------- public\n\n    function factor() public view returns (uint256) {\n      Factor memory _factor = _valueAtFactorLast();\n      uint256 result = _factor.factor;\n      for (uint256 i = 0; i < _factor.refactorCount; i++) {\n        result = result * REFACTOR_DIVIDER;\n      }\n      return result;\n    }\n\n    // -------- internal\n\n    function _mint(address account, uint256 amount) internal {\n      require(account != address(0), \"AutoRefactorCoinage: mint to the zero address\");\n\n      Balance memory _totalBalance = _valueAtTotalSupplyLast();\n      Balance memory _accountBalance = _valueAtAccountBalanceLast(account);\n\n      uint256 currentAccountBalance = applyFactor(_accountBalance);\n      uint256 currentTotalBalance = applyFactor(_totalBalance);\n\n      uint256 rbAmountAccount = _toRAYBased(currentAccountBalance + amount);\n      uint256 rbAmountTotal = _toRAYBased(currentTotalBalance + amount);\n\n      Balance memory newAccountBalance = Balance(rbAmountAccount, _accountBalance.refactoredCount);\n      Balance memory newTotalBalance = Balance(rbAmountTotal, _totalBalance.refactoredCount);\n\n      _update(newAccountBalance, newTotalBalance, account, true, true);\n\n      emit ChangedBalance(account, _accountBalance, newAccountBalance, _totalBalance, newTotalBalance);\n\n      emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n      require(account != address(0), \"AutoRefactorCoinage: burn from the zero address\");\n\n      Balance memory _totalBalance = _valueAtTotalSupplyLast();\n      Balance memory _accountBalance = _valueAtAccountBalanceLast(account);\n\n      uint256 currentAccountBalance = applyFactor(_accountBalance);\n      uint256 currentTotalBalance = applyFactor(_totalBalance);\n\n      require(currentAccountBalance >= amount\n        && currentTotalBalance >= amount, \"insufficient balance\");\n\n      // uint256 rbAmountAccount = _toRAYBased(currentAccountBalance - amount);\n      // uint256 rbAmountTotal = _toRAYBased(currentTotalBalance - amount);\n\n      Balance memory newAccountBalance = Balance( _toRAYBased(currentAccountBalance - amount), _accountBalance.refactoredCount);\n      Balance memory newTotalBalance = Balance(_toRAYBased(currentTotalBalance - amount), _totalBalance.refactoredCount);\n\n      _update(newAccountBalance, newTotalBalance, account, true, true);\n\n      emit ChangedBalance(account, _accountBalance, newAccountBalance, _totalBalance, newTotalBalance);\n\n      emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @param v the value to be factored\n     */\n    function _applyFactor(uint256 v, uint256 refactoredCount) internal view returns (uint256) {\n\n      if (v == 0) {\n        return 0;\n      }\n\n      Factor memory _factor = _valueAtFactorLast();\n\n      v = rmul2(v, _factor.factor);\n\n      for (uint256 i = refactoredCount; i < _factor.refactorCount; i++) {\n        v = v * REFACTOR_DIVIDER;\n      }\n\n      return v;\n    }\n\n    function _applyFactorAt(Balance memory _balance, Factor memory _factor) internal view returns (uint256) {\n\n      if (_balance.balance == 0) {\n        return 0;\n      }\n\n      _balance.balance = rmul2(_balance.balance, _factor.factor);\n\n      for (uint256 i = _balance.refactoredCount; i < _factor.refactorCount; i++) {\n        _balance.balance = _balance.balance * REFACTOR_DIVIDER;\n      }\n\n      return _balance.balance;\n    }\n\n    /**\n     * @dev Calculate RAY BASED from RAY FACTORED\n     */\n    function _toRAYBased(uint256 rf) internal view returns (uint256 rb) {\n      return rdiv2(rf, (_valueAtFactorLast()).factor);\n    }\n\n    /**\n     * @dev Calculate RAY FACTORED from RAY BASED\n     */\n    function _toRAYFactored(uint256 rb) internal view returns (uint256 rf) {\n      return rmul2(rb, (_valueAtFactorLast()).factor);\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) internal view returns (uint256) {\n        return (ids.length == 0? 0: ids[ids.length - 1]);\n    }\n\n    function _updateFactor(Factor memory _factor) internal {\n\n      uint256 currentId = progressSnapshotId();\n      uint256 factorIndex = _lastSnapshotId(factorSnapshotIds);\n\n      if (factorIndex < currentId) factorSnapshotIds.push(currentId);\n      factorSnapshots[currentId] = _factor;\n    }\n\n    function _update(\n      Balance memory _accountBalance,\n      Balance memory _totalBalance,\n      address account,\n      bool accountBool,\n      bool totalBool\n    ) internal  {\n\n      uint256 currentId = progressSnapshotId();\n      uint256 balanceIndex = _lastSnapshotId(accountBalanceIds[account]);\n      uint256 totalIndex = _lastSnapshotId(totalSupplySnapshotIds);\n\n      if (accountBool) {\n        require(account != address(0), \"zero account\");\n        if (balanceIndex < currentId) accountBalanceIds[account].push(currentId);\n        accountBalanceSnapshots[account][currentId] = _accountBalance;\n      }\n\n      if (totalBool) {\n        if (totalIndex < currentId) totalSupplySnapshotIds.push(currentId);\n        totalSupplySnapshots[currentId] = _totalBalance;\n      }\n    }\n\n    function progressSnapshotId() public view returns (uint256) {\n        return lastSnapshotId;\n    }\n\n    function applyFactor(Balance memory _balance) public view returns (uint256 amount) {\n      return _applyFactor(_balance.balance, _balance.refactoredCount);\n    }\n\n    function totalSupply() public view returns (uint256 amount)\n    {\n      amount = applyFactor(_valueAtTotalSupplyLast());\n    }\n\n    function balanceOf(address account) public view returns (uint256 amount)\n    {\n      amount = applyFactor(_valueAtAccountBalanceLast(account));\n    }\n\n    function totalSupplyAt(uint256 snapshotId) public view returns (uint256 amount)\n    {\n        if (snapshotId > 0) {\n            (bool snapshotted1, Balance memory _balance) = _valueAtTotalSupply(snapshotId);\n            (bool snapshotted2, Factor memory _factor) = _valueAtFactor(snapshotId);\n\n            if (snapshotted1 && snapshotted2) {\n                amount = _applyFactorAt(_balance, _factor);\n            }\n        }\n    }\n\n    function balanceOfAt(uint256 snapshotId, address account) public view\n      returns (uint256 amount)\n    {\n      if (snapshotId > 0) {\n          (bool snapshotted1, Balance memory _balance) = _valueAtAccount(snapshotId, account);\n          (bool snapshotted2, Factor memory _factor) = _valueAtFactor(snapshotId);\n\n          if (snapshotted1 && snapshotted2) {\n              amount = _applyFactorAt(_balance, _factor);\n          }\n      }\n    }\n\n    function _valueAtTotalSupplyLast() internal view\n      returns (Balance memory)\n    {\n      uint256 index = 0;\n      if(totalSupplySnapshotIds.length != 0) index = totalSupplySnapshotIds.length - 1;\n      return totalSupplySnapshots[index];\n    }\n\n    function _valueAtFactorLast() internal view\n      returns (Factor memory)\n    {\n      uint256 index = 0;\n      if(factorSnapshotIds.length != 0) index = factorSnapshotIds.length - 1;\n      return factorSnapshots[index];\n    }\n\n    function _valueAtAccountBalanceLast(address account) internal view\n      returns (Balance memory)\n    {\n      uint256 index = 0;\n      if(accountBalanceIds[account].length != 0) index = accountBalanceIds[account].length - 1;\n      return accountBalanceSnapshots[account][index];\n    }\n\n    function _valueAtTotalSupply(uint256 snapshotId) internal view\n      returns (bool snapshotted, Balance memory balance)\n    {\n      if (snapshotId > 0 && snapshotId <= progressSnapshotId()) {\n        uint256 index = totalSupplySnapshotIds.findIndex(snapshotId);\n        if (index == totalSupplySnapshotIds.length) {\n          if (index > 0) {\n            snapshotted = true;\n            balance = totalSupplySnapshots[index-1];\n          } else {\n            snapshotted = false;\n          }\n        } else {\n          snapshotted = true;\n          balance = totalSupplySnapshots[index];\n        }\n      }\n    }\n\n    function _valueAtFactor(uint256 snapshotId) internal view\n      returns (bool snapshotted, Factor memory factor_)\n    {\n      if (snapshotId > 0 && snapshotId <= progressSnapshotId()) {\n        uint256 index = factorSnapshotIds.findIndex(snapshotId);\n        if (index == factorSnapshotIds.length) {\n          if (index > 0) {\n            snapshotted = true;\n            factor_ = factorSnapshots[index-1];\n          } else {\n              snapshotted = false;\n          }\n        } else {\n          snapshotted = true;\n          factor_ = factorSnapshots[index];\n        }\n      }\n    }\n\n    function _valueAtAccount(uint256 snapshotId, address account) internal view\n        returns (bool snapshotted, Balance memory balance)\n    {\n        if (snapshotId > 0 && snapshotId <= progressSnapshotId()) {\n          uint256 index = accountBalanceIds[account].findIndex(snapshotId);\n          if (index == accountBalanceIds[account].length) {\n            if (index > 0) {\n              snapshotted = true;\n              balance = accountBalanceSnapshots[account][index-1];\n            } else {\n              snapshotted = false;\n            }\n          } else {\n            snapshotted = true;\n            balance = accountBalanceSnapshots[account][index];\n\n          }\n        }\n    }\n\n}\n"
    },
    "contracts/stake/tokens/RefactorCoinageSnapshotProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../proxy/ProxyCoinage.sol\";\nimport \"./RefactorCoinageSnapshotStorage.sol\";\n\n/**\n * @title\n * @dev\n */\ncontract RefactorCoinageSnapshotProxy is ProxyCoinage, RefactorCoinageSnapshotStorage {\n\n}\n"
    },
    "contracts/stake/tokens/RefactorCoinageSnapshotStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title\n/// @notice\ncontract RefactorCoinageSnapshotStorage   {\n\n    struct Balance {\n        uint256 balance;\n        uint256 refactoredCount;\n    }\n\n    struct Factor {\n        uint256 factor;\n        uint256 refactorCount;\n    }\n\n    uint256 public REFACTOR_BOUNDARY = 10 ** 28;\n    uint256 public REFACTOR_DIVIDER = 2;\n\n    // uint256 public refactorCount;\n    // uint256 public _factor;\n    // bool internal _transfersEnabled;\n\n    //=== ERC20\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => uint256)) public _allowances;\n\n    //---------------\n    uint256[] public totalSupplySnapshotIds;\n    mapping (uint256 => Balance) public totalSupplySnapshots;\n\n    uint256[] public factorSnapshotIds;\n    mapping (uint256 => Factor) public factorSnapshots;\n\n    mapping (address => uint256[]) public accountBalanceIds;\n    mapping (address => mapping (uint256 => Balance)) public accountBalanceSnapshots;\n\n    uint256 public lastSnapshotId;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}